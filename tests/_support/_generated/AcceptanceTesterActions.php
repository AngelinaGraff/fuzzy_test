<?php  //[STAMP] 6c015fb694b37684546f6c59652ab4f4
// phpcs:ignoreFile
namespace _generated;

// This class was automatically generated by build task
// You should not change it manually as it will be overwritten on next build

trait AcceptanceTesterActions
{
    /**
     * @return \Codeception\Scenario
     */
    abstract protected function getScenario();

    
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Alias to `haveHttpHeader`
     * @see \Codeception\Module\PhpBrowser::setHeader()
     */
    public function setHeader(string $name, string $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('setHeader', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Alias to `haveHttpHeader`
     * @see \Codeception\Module\PhpBrowser::setHeader()
     */
    public function tryToSetHeader(string $name, string $value): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('setHeader', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes setHeader and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\PhpBrowser::setHeader()
     */
    public function retrySetHeader(string $name, string $value) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('setHeader', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Authenticates user for HTTP_AUTH
     * @see \Codeception\Lib\InnerBrowser::amHttpAuthenticated()
     */
    public function amHttpAuthenticated(string $username, string $password): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amHttpAuthenticated', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Open web page at the given absolute URL and sets its hostname as the base host.
     *
     * ``` php
     * <?php
     * $I->amOnUrl('https://codeception.com');
     * $I->amOnPage('/quickstart'); // moves to https://codeception.com/quickstart
     * ```
     * @see \Codeception\Module\PhpBrowser::amOnUrl()
     */
    public function amOnUrl($url): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amOnUrl', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Changes the subdomain for the 'url' configuration parameter.
     * Does not open a page; use `amOnPage` for that.
     *
     * ``` php
     * <?php
     * // If config is: 'https://mysite.com'
     * // or config is: 'https://www.mysite.com'
     * // or config is: 'https://company.mysite.com'
     *
     * $I->amOnSubdomain('user');
     * $I->amOnPage('/');
     * // moves to https://user.mysite.com/
     * ```
     *
     * @see \Codeception\Module\PhpBrowser::amOnSubdomain()
     */
    public function amOnSubdomain($subdomain): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amOnSubdomain', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Low-level API method.
     * If Codeception commands are not enough, use [Guzzle HTTP Client](https://guzzlephp.org/) methods directly
     *
     * Example:
     *
     * ``` php
     * <?php
     * $I->executeInGuzzle(function (\GuzzleHttp\Client $client) {
     *      $client->get('/get', ['query' => ['foo' => 'bar']]);
     * });
     * ```
     *
     * It is not recommended to use this command on a regular basis.
     * If Codeception lacks important Guzzle Client methods, implement them and submit patches.
     *
     * @return mixed
     * @see \Codeception\Module\PhpBrowser::executeInGuzzle()
     */
    public function executeInGuzzle(\Closure $function) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('executeInGuzzle', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Low-level API method.
     * If Codeception commands are not enough, use [Guzzle HTTP Client](https://guzzlephp.org/) methods directly
     *
     * Example:
     *
     * ``` php
     * <?php
     * $I->executeInGuzzle(function (\GuzzleHttp\Client $client) {
     *      $client->get('/get', ['query' => ['foo' => 'bar']]);
     * });
     * ```
     *
     * It is not recommended to use this command on a regular basis.
     * If Codeception lacks important Guzzle Client methods, implement them and submit patches.
     *
     * @return mixed
     * @see \Codeception\Module\PhpBrowser::executeInGuzzle()
     */
    public function tryToExecuteInGuzzle(\Closure $function): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('executeInGuzzle', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes executeInGuzzle and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\PhpBrowser::executeInGuzzle()
     */
    public function retryExecuteInGuzzle(\Closure $function) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('executeInGuzzle', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sets the HTTP header to the passed value - which is used on
     * subsequent HTTP requests through PhpBrowser.
     *
     * Example:
     * ```php
     * <?php
     * $I->haveHttpHeader('X-Requested-With', 'Codeception');
     * $I->amOnPage('test-headers.php');
     * ```
     *
     * To use special chars in Header Key use HTML Character Entities:
     * Example:
     * Header with underscore - 'Client_Id'
     * should be represented as - 'Client&#x0005F;Id' or 'Client&#95;Id'
     *
     * ```php
     * <?php
     * $I->haveHttpHeader('Client&#95;Id', 'Codeception');
     * ```
     *
     * @param string $name the name of the request header
     * @param string $value the value to set it to for subsequent
     *        requests
     * @see \Codeception\Lib\InnerBrowser::haveHttpHeader()
     */
    public function haveHttpHeader(string $name, string $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('haveHttpHeader', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Unsets a HTTP header (that was originally added by [haveHttpHeader()](#haveHttpHeader)),
     * so that subsequent requests will not send it anymore.
     *
     * Example:
     * ```php
     * <?php
     * $I->haveHttpHeader('X-Requested-With', 'Codeception');
     * $I->amOnPage('test-headers.php');
     * // ...
     * $I->unsetHeader('X-Requested-With');
     * $I->amOnPage('some-other-page.php');
     * ```
     *
     * @param string $name the name of the header to unset.
     * @see \Codeception\Lib\InnerBrowser::unsetHttpHeader()
     */
    public function unsetHttpHeader(string $name): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('unsetHttpHeader', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Unsets a HTTP header (that was originally added by [haveHttpHeader()](#haveHttpHeader)),
     * so that subsequent requests will not send it anymore.
     *
     * Example:
     * ```php
     * <?php
     * $I->haveHttpHeader('X-Requested-With', 'Codeception');
     * $I->amOnPage('test-headers.php');
     * // ...
     * $I->unsetHeader('X-Requested-With');
     * $I->amOnPage('some-other-page.php');
     * ```
     *
     * @param string $name the name of the header to unset.
     * @see \Codeception\Lib\InnerBrowser::unsetHttpHeader()
     */
    public function tryToUnsetHttpHeader(string $name): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('unsetHttpHeader', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes unsetHttpHeader and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::unsetHttpHeader()
     */
    public function retryUnsetHttpHeader(string $name) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('unsetHttpHeader', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * @deprecated Use [unsetHttpHeader](#unsetHttpHeader) instead
     * @see \Codeception\Lib\InnerBrowser::deleteHeader()
     */
    public function deleteHeader(string $name): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('deleteHeader', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * @deprecated Use [unsetHttpHeader](#unsetHttpHeader) instead
     * @see \Codeception\Lib\InnerBrowser::deleteHeader()
     */
    public function tryToDeleteHeader(string $name): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('deleteHeader', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes deleteHeader and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::deleteHeader()
     */
    public function retryDeleteHeader(string $name) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('deleteHeader', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Opens the page for the given relative URI.
     *
     * ```php
     * <?php
     * // opens front page
     * $I->amOnPage('/');
     * // opens /register page
     * $I->amOnPage('/register');
     * ```
     * @see \Codeception\Lib\InnerBrowser::amOnPage()
     */
    public function amOnPage(string $page): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amOnPage', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Perform a click on a link or a button, given by a locator.
     * If a fuzzy locator is given, the page will be searched for a button, link, or image matching the locator string.
     * For buttons, the "value" attribute, "name" attribute, and inner text are searched.
     * For links, the link text is searched.
     * For images, the "alt" attribute and inner text of any parent links are searched.
     *
     * The second parameter is a context (CSS or XPath locator) to narrow the search.
     *
     * Note that if the locator matches a button of type `submit`, the form will be submitted.
     *
     * ```php
     * <?php
     * // simple link
     * $I->click('Logout');
     * // button of form
     * $I->click('Submit');
     * // CSS button
     * $I->click('#form input[type=submit]');
     * // XPath
     * $I->click('//form/*[@type="submit"]');
     * // link in context
     * $I->click('Logout', '#nav');
     * // using strict locator
     * $I->click(['link' => 'Login']);
     * ```
     * @param string|array $link
     * @see \Codeception\Lib\InnerBrowser::click()
     */
    public function click($link, $context = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('click', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Perform a click on a link or a button, given by a locator.
     * If a fuzzy locator is given, the page will be searched for a button, link, or image matching the locator string.
     * For buttons, the "value" attribute, "name" attribute, and inner text are searched.
     * For links, the link text is searched.
     * For images, the "alt" attribute and inner text of any parent links are searched.
     *
     * The second parameter is a context (CSS or XPath locator) to narrow the search.
     *
     * Note that if the locator matches a button of type `submit`, the form will be submitted.
     *
     * ```php
     * <?php
     * // simple link
     * $I->click('Logout');
     * // button of form
     * $I->click('Submit');
     * // CSS button
     * $I->click('#form input[type=submit]');
     * // XPath
     * $I->click('//form/*[@type="submit"]');
     * // link in context
     * $I->click('Logout', '#nav');
     * // using strict locator
     * $I->click(['link' => 'Login']);
     * ```
     * @param string|array $link
     * @see \Codeception\Lib\InnerBrowser::click()
     */
    public function tryToClick($link, $context = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('click', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes click and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::click()
     */
    public function retryClick($link, $context = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('click', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current page contains the given string (case insensitive).
     *
     * You can specify a specific HTML element (via CSS or XPath) as the second
     * parameter to only search within that element.
     *
     * ```php
     * <?php
     * $I->see('Logout');                        // I can suppose user is logged in
     * $I->see('Sign Up', 'h1');                 // I can suppose it's a signup page
     * $I->see('Sign Up', '//body/h1');          // with XPath
     * $I->see('Sign Up', ['css' => 'body h1']); // with strict CSS locator
     * ```
     *
     * Note that the search is done after stripping all HTML tags from the body,
     * so `$I->see('strong')` will return true for strings like:
     *
     *   - `<p>I am Stronger than thou</p>`
     *   - `<script>document.createElement('strong');</script>`
     *
     * But will *not* be true for strings like:
     *
     *   - `<strong>Home</strong>`
     *   - `<div class="strong">Home</strong>`
     *   - `<!-- strong -->`
     *
     * For checking the raw source code, use `seeInSource()`.
     *
     * @param array|string $selector optional
     * @see \Codeception\Lib\InnerBrowser::see()
     */
    public function see(string $text, $selector = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('see', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current page contains the given string (case insensitive).
     *
     * You can specify a specific HTML element (via CSS or XPath) as the second
     * parameter to only search within that element.
     *
     * ```php
     * <?php
     * $I->see('Logout');                        // I can suppose user is logged in
     * $I->see('Sign Up', 'h1');                 // I can suppose it's a signup page
     * $I->see('Sign Up', '//body/h1');          // with XPath
     * $I->see('Sign Up', ['css' => 'body h1']); // with strict CSS locator
     * ```
     *
     * Note that the search is done after stripping all HTML tags from the body,
     * so `$I->see('strong')` will return true for strings like:
     *
     *   - `<p>I am Stronger than thou</p>`
     *   - `<script>document.createElement('strong');</script>`
     *
     * But will *not* be true for strings like:
     *
     *   - `<strong>Home</strong>`
     *   - `<div class="strong">Home</strong>`
     *   - `<!-- strong -->`
     *
     * For checking the raw source code, use `seeInSource()`.
     *
     * @param array|string $selector optional
     * @see \Codeception\Lib\InnerBrowser::see()
     */
    public function canSee(string $text, $selector = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('see', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current page contains the given string (case insensitive).
     *
     * You can specify a specific HTML element (via CSS or XPath) as the second
     * parameter to only search within that element.
     *
     * ```php
     * <?php
     * $I->see('Logout');                        // I can suppose user is logged in
     * $I->see('Sign Up', 'h1');                 // I can suppose it's a signup page
     * $I->see('Sign Up', '//body/h1');          // with XPath
     * $I->see('Sign Up', ['css' => 'body h1']); // with strict CSS locator
     * ```
     *
     * Note that the search is done after stripping all HTML tags from the body,
     * so `$I->see('strong')` will return true for strings like:
     *
     *   - `<p>I am Stronger than thou</p>`
     *   - `<script>document.createElement('strong');</script>`
     *
     * But will *not* be true for strings like:
     *
     *   - `<strong>Home</strong>`
     *   - `<div class="strong">Home</strong>`
     *   - `<!-- strong -->`
     *
     * For checking the raw source code, use `seeInSource()`.
     *
     * @param array|string $selector optional
     * @see \Codeception\Lib\InnerBrowser::see()
     */
    public function tryToSee(string $text, $selector = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('see', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes see and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::see()
     */
    public function retrySee(string $text, $selector = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('see', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current page doesn't contain the text specified (case insensitive).
     * Give a locator as the second parameter to match a specific region.
     *
     * ```php
     * <?php
     * $I->dontSee('Login');                         // I can suppose user is already logged in
     * $I->dontSee('Sign Up','h1');                  // I can suppose it's not a signup page
     * $I->dontSee('Sign Up','//body/h1');           // with XPath
     * $I->dontSee('Sign Up', ['css' => 'body h1']); // with strict CSS locator
     * ```
     *
     * Note that the search is done after stripping all HTML tags from the body,
     * so `$I->dontSee('strong')` will fail on strings like:
     *
     *   - `<p>I am Stronger than thou</p>`
     *   - `<script>document.createElement('strong');</script>`
     *
     * But will ignore strings like:
     *
     *   - `<strong>Home</strong>`
     *   - `<div class="strong">Home</strong>`
     *   - `<!-- strong -->`
     *
     * For checking the raw source code, use `seeInSource()`.
     *
     * @param array|string $selector optional
     * @see \Codeception\Lib\InnerBrowser::dontSee()
     */
    public function dontSee(string $text, $selector = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSee', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current page doesn't contain the text specified (case insensitive).
     * Give a locator as the second parameter to match a specific region.
     *
     * ```php
     * <?php
     * $I->dontSee('Login');                         // I can suppose user is already logged in
     * $I->dontSee('Sign Up','h1');                  // I can suppose it's not a signup page
     * $I->dontSee('Sign Up','//body/h1');           // with XPath
     * $I->dontSee('Sign Up', ['css' => 'body h1']); // with strict CSS locator
     * ```
     *
     * Note that the search is done after stripping all HTML tags from the body,
     * so `$I->dontSee('strong')` will fail on strings like:
     *
     *   - `<p>I am Stronger than thou</p>`
     *   - `<script>document.createElement('strong');</script>`
     *
     * But will ignore strings like:
     *
     *   - `<strong>Home</strong>`
     *   - `<div class="strong">Home</strong>`
     *   - `<!-- strong -->`
     *
     * For checking the raw source code, use `seeInSource()`.
     *
     * @param array|string $selector optional
     * @see \Codeception\Lib\InnerBrowser::dontSee()
     */
    public function cantSee(string $text, $selector = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSee', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current page doesn't contain the text specified (case insensitive).
     * Give a locator as the second parameter to match a specific region.
     *
     * ```php
     * <?php
     * $I->dontSee('Login');                         // I can suppose user is already logged in
     * $I->dontSee('Sign Up','h1');                  // I can suppose it's not a signup page
     * $I->dontSee('Sign Up','//body/h1');           // with XPath
     * $I->dontSee('Sign Up', ['css' => 'body h1']); // with strict CSS locator
     * ```
     *
     * Note that the search is done after stripping all HTML tags from the body,
     * so `$I->dontSee('strong')` will fail on strings like:
     *
     *   - `<p>I am Stronger than thou</p>`
     *   - `<script>document.createElement('strong');</script>`
     *
     * But will ignore strings like:
     *
     *   - `<strong>Home</strong>`
     *   - `<div class="strong">Home</strong>`
     *   - `<!-- strong -->`
     *
     * For checking the raw source code, use `seeInSource()`.
     *
     * @param array|string $selector optional
     * @see \Codeception\Lib\InnerBrowser::dontSee()
     */
    public function tryToDontSee(string $text, $selector = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSee', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSee and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSee()
     */
    public function retryDontSee(string $text, $selector = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSee', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current page contains the given string in its
     * raw source code.
     *
     * ```php
     * <?php
     * $I->seeInSource('<h1>Green eggs &amp; ham</h1>');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInSource()
     */
    public function seeInSource(string $raw): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInSource', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current page contains the given string in its
     * raw source code.
     *
     * ```php
     * <?php
     * $I->seeInSource('<h1>Green eggs &amp; ham</h1>');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInSource()
     */
    public function canSeeInSource(string $raw): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInSource', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current page contains the given string in its
     * raw source code.
     *
     * ```php
     * <?php
     * $I->seeInSource('<h1>Green eggs &amp; ham</h1>');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInSource()
     */
    public function tryToSeeInSource(string $raw): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInSource', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInSource and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeInSource()
     */
    public function retrySeeInSource(string $raw) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInSource', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current page contains the given string in its
     * raw source code.
     *
     * ```php
     * <?php
     * $I->dontSeeInSource('<h1>Green eggs &amp; ham</h1>');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInSource()
     */
    public function dontSeeInSource(string $raw): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeInSource', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current page contains the given string in its
     * raw source code.
     *
     * ```php
     * <?php
     * $I->dontSeeInSource('<h1>Green eggs &amp; ham</h1>');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInSource()
     */
    public function cantSeeInSource(string $raw): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeInSource', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current page contains the given string in its
     * raw source code.
     *
     * ```php
     * <?php
     * $I->dontSeeInSource('<h1>Green eggs &amp; ham</h1>');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInSource()
     */
    public function tryToDontSeeInSource(string $raw): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeInSource', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeInSource and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeInSource()
     */
    public function retryDontSeeInSource(string $raw) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeInSource', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that there's a link with the specified text.
     * Give a full URL as the second parameter to match links with that exact URL.
     *
     * ```php
     * <?php
     * $I->seeLink('Logout'); // matches <a href="#">Logout</a>
     * $I->seeLink('Logout','/logout'); // matches <a href="/logout">Logout</a>
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeLink()
     */
    public function seeLink(string $text, ?string $url = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeLink', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that there's a link with the specified text.
     * Give a full URL as the second parameter to match links with that exact URL.
     *
     * ```php
     * <?php
     * $I->seeLink('Logout'); // matches <a href="#">Logout</a>
     * $I->seeLink('Logout','/logout'); // matches <a href="/logout">Logout</a>
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeLink()
     */
    public function canSeeLink(string $text, ?string $url = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeLink', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that there's a link with the specified text.
     * Give a full URL as the second parameter to match links with that exact URL.
     *
     * ```php
     * <?php
     * $I->seeLink('Logout'); // matches <a href="#">Logout</a>
     * $I->seeLink('Logout','/logout'); // matches <a href="/logout">Logout</a>
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeLink()
     */
    public function tryToSeeLink(string $text, ?string $url = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeLink', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeLink and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeLink()
     */
    public function retrySeeLink(string $text, ?string $url = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeLink', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the page doesn't contain a link with the given string.
     * If the second parameter is given, only links with a matching "href" attribute will be checked.
     *
     * ```php
     * <?php
     * $I->dontSeeLink('Logout'); // I suppose user is not logged in
     * $I->dontSeeLink('Checkout now', '/store/cart.php');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeLink()
     */
    public function dontSeeLink(string $text, string $url = ""): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeLink', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the page doesn't contain a link with the given string.
     * If the second parameter is given, only links with a matching "href" attribute will be checked.
     *
     * ```php
     * <?php
     * $I->dontSeeLink('Logout'); // I suppose user is not logged in
     * $I->dontSeeLink('Checkout now', '/store/cart.php');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeLink()
     */
    public function cantSeeLink(string $text, string $url = ""): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeLink', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the page doesn't contain a link with the given string.
     * If the second parameter is given, only links with a matching "href" attribute will be checked.
     *
     * ```php
     * <?php
     * $I->dontSeeLink('Logout'); // I suppose user is not logged in
     * $I->dontSeeLink('Checkout now', '/store/cart.php');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeLink()
     */
    public function tryToDontSeeLink(string $text, string $url = ""): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeLink', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeLink and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeLink()
     */
    public function retryDontSeeLink(string $text, string $url = "") {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeLink', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that current URI contains the given string.
     *
     * ```php
     * <?php
     * // to match: /home/dashboard
     * $I->seeInCurrentUrl('home');
     * // to match: /users/1
     * $I->seeInCurrentUrl('/users/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInCurrentUrl()
     */
    public function seeInCurrentUrl(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInCurrentUrl', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that current URI contains the given string.
     *
     * ```php
     * <?php
     * // to match: /home/dashboard
     * $I->seeInCurrentUrl('home');
     * // to match: /users/1
     * $I->seeInCurrentUrl('/users/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInCurrentUrl()
     */
    public function canSeeInCurrentUrl(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInCurrentUrl', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that current URI contains the given string.
     *
     * ```php
     * <?php
     * // to match: /home/dashboard
     * $I->seeInCurrentUrl('home');
     * // to match: /users/1
     * $I->seeInCurrentUrl('/users/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInCurrentUrl()
     */
    public function tryToSeeInCurrentUrl(string $uri): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInCurrentUrl', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInCurrentUrl and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeInCurrentUrl()
     */
    public function retrySeeInCurrentUrl(string $uri) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInCurrentUrl', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current URI doesn't contain the given string.
     *
     * ```php
     * <?php
     * $I->dontSeeInCurrentUrl('/users/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInCurrentUrl()
     */
    public function dontSeeInCurrentUrl(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeInCurrentUrl', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current URI doesn't contain the given string.
     *
     * ```php
     * <?php
     * $I->dontSeeInCurrentUrl('/users/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInCurrentUrl()
     */
    public function cantSeeInCurrentUrl(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeInCurrentUrl', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current URI doesn't contain the given string.
     *
     * ```php
     * <?php
     * $I->dontSeeInCurrentUrl('/users/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInCurrentUrl()
     */
    public function tryToDontSeeInCurrentUrl(string $uri): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeInCurrentUrl', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeInCurrentUrl and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeInCurrentUrl()
     */
    public function retryDontSeeInCurrentUrl(string $uri) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeInCurrentUrl', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current URL is equal to the given string.
     * Unlike `seeInCurrentUrl`, this only matches the full URL.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->seeCurrentUrlEquals('/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlEquals()
     */
    public function seeCurrentUrlEquals(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeCurrentUrlEquals', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current URL is equal to the given string.
     * Unlike `seeInCurrentUrl`, this only matches the full URL.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->seeCurrentUrlEquals('/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlEquals()
     */
    public function canSeeCurrentUrlEquals(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeCurrentUrlEquals', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current URL is equal to the given string.
     * Unlike `seeInCurrentUrl`, this only matches the full URL.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->seeCurrentUrlEquals('/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlEquals()
     */
    public function tryToSeeCurrentUrlEquals(string $uri): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeCurrentUrlEquals', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeCurrentUrlEquals and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlEquals()
     */
    public function retrySeeCurrentUrlEquals(string $uri) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeCurrentUrlEquals', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current URL doesn't equal the given string.
     * Unlike `dontSeeInCurrentUrl`, this only matches the full URL.
     *
     * ```php
     * <?php
     * // current url is not root
     * $I->dontSeeCurrentUrlEquals('/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlEquals()
     */
    public function dontSeeCurrentUrlEquals(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeCurrentUrlEquals', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current URL doesn't equal the given string.
     * Unlike `dontSeeInCurrentUrl`, this only matches the full URL.
     *
     * ```php
     * <?php
     * // current url is not root
     * $I->dontSeeCurrentUrlEquals('/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlEquals()
     */
    public function cantSeeCurrentUrlEquals(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeCurrentUrlEquals', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current URL doesn't equal the given string.
     * Unlike `dontSeeInCurrentUrl`, this only matches the full URL.
     *
     * ```php
     * <?php
     * // current url is not root
     * $I->dontSeeCurrentUrlEquals('/');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlEquals()
     */
    public function tryToDontSeeCurrentUrlEquals(string $uri): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeCurrentUrlEquals', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeCurrentUrlEquals and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlEquals()
     */
    public function retryDontSeeCurrentUrlEquals(string $uri) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeCurrentUrlEquals', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the current URL matches the given regular expression.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->seeCurrentUrlMatches('~^/users/(\d+)~');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlMatches()
     */
    public function seeCurrentUrlMatches(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeCurrentUrlMatches', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the current URL matches the given regular expression.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->seeCurrentUrlMatches('~^/users/(\d+)~');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlMatches()
     */
    public function canSeeCurrentUrlMatches(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeCurrentUrlMatches', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the current URL matches the given regular expression.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->seeCurrentUrlMatches('~^/users/(\d+)~');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlMatches()
     */
    public function tryToSeeCurrentUrlMatches(string $uri): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeCurrentUrlMatches', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeCurrentUrlMatches and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeCurrentUrlMatches()
     */
    public function retrySeeCurrentUrlMatches(string $uri) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeCurrentUrlMatches', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that current url doesn't match the given regular expression.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->dontSeeCurrentUrlMatches('~^/users/(\d+)~');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlMatches()
     */
    public function dontSeeCurrentUrlMatches(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeCurrentUrlMatches', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that current url doesn't match the given regular expression.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->dontSeeCurrentUrlMatches('~^/users/(\d+)~');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlMatches()
     */
    public function cantSeeCurrentUrlMatches(string $uri): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeCurrentUrlMatches', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that current url doesn't match the given regular expression.
     *
     * ```php
     * <?php
     * // to match root url
     * $I->dontSeeCurrentUrlMatches('~^/users/(\d+)~');
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlMatches()
     */
    public function tryToDontSeeCurrentUrlMatches(string $uri): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeCurrentUrlMatches', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeCurrentUrlMatches and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeCurrentUrlMatches()
     */
    public function retryDontSeeCurrentUrlMatches(string $uri) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeCurrentUrlMatches', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Executes the given regular expression against the current URI and returns the first capturing group.
     * If no parameters are provided, the full URI is returned.
     *
     * ```php
     * <?php
     * $user_id = $I->grabFromCurrentUrl('~^/user/(\d+)/~');
     * $uri = $I->grabFromCurrentUrl();
     * ```
     * @see \Codeception\Lib\InnerBrowser::grabFromCurrentUrl()
     */
    public function grabFromCurrentUrl(?string $uri = NULL): mixed {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabFromCurrentUrl', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabFromCurrentUrl and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::grabFromCurrentUrl()
     */
    public function retryGrabFromCurrentUrl(?string $uri = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabFromCurrentUrl', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the specified checkbox is checked.
     *
     * ```php
     * <?php
     * $I->seeCheckboxIsChecked('#agree'); // I suppose user agreed to terms
     * $I->seeCheckboxIsChecked('#signup_form input[type=checkbox]'); // I suppose user agreed to terms, If there is only one checkbox in form.
     * $I->seeCheckboxIsChecked('//form/input[@type=checkbox and @name=agree]');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCheckboxIsChecked()
     */
    public function seeCheckboxIsChecked($checkbox): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeCheckboxIsChecked', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the specified checkbox is checked.
     *
     * ```php
     * <?php
     * $I->seeCheckboxIsChecked('#agree'); // I suppose user agreed to terms
     * $I->seeCheckboxIsChecked('#signup_form input[type=checkbox]'); // I suppose user agreed to terms, If there is only one checkbox in form.
     * $I->seeCheckboxIsChecked('//form/input[@type=checkbox and @name=agree]');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCheckboxIsChecked()
     */
    public function canSeeCheckboxIsChecked($checkbox): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeCheckboxIsChecked', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the specified checkbox is checked.
     *
     * ```php
     * <?php
     * $I->seeCheckboxIsChecked('#agree'); // I suppose user agreed to terms
     * $I->seeCheckboxIsChecked('#signup_form input[type=checkbox]'); // I suppose user agreed to terms, If there is only one checkbox in form.
     * $I->seeCheckboxIsChecked('//form/input[@type=checkbox and @name=agree]');
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeCheckboxIsChecked()
     */
    public function tryToSeeCheckboxIsChecked($checkbox): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeCheckboxIsChecked', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeCheckboxIsChecked and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeCheckboxIsChecked()
     */
    public function retrySeeCheckboxIsChecked($checkbox) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeCheckboxIsChecked', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Check that the specified checkbox is unchecked.
     *
     * ```php
     * <?php
     * $I->dontSeeCheckboxIsChecked('#agree'); // I suppose user didn't agree to terms
     * $I->seeCheckboxIsChecked('#signup_form input[type=checkbox]'); // I suppose user didn't check the first checkbox in form.
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCheckboxIsChecked()
     */
    public function dontSeeCheckboxIsChecked($checkbox): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeCheckboxIsChecked', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Check that the specified checkbox is unchecked.
     *
     * ```php
     * <?php
     * $I->dontSeeCheckboxIsChecked('#agree'); // I suppose user didn't agree to terms
     * $I->seeCheckboxIsChecked('#signup_form input[type=checkbox]'); // I suppose user didn't check the first checkbox in form.
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCheckboxIsChecked()
     */
    public function cantSeeCheckboxIsChecked($checkbox): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeCheckboxIsChecked', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Check that the specified checkbox is unchecked.
     *
     * ```php
     * <?php
     * $I->dontSeeCheckboxIsChecked('#agree'); // I suppose user didn't agree to terms
     * $I->seeCheckboxIsChecked('#signup_form input[type=checkbox]'); // I suppose user didn't check the first checkbox in form.
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeCheckboxIsChecked()
     */
    public function tryToDontSeeCheckboxIsChecked($checkbox): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeCheckboxIsChecked', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeCheckboxIsChecked and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeCheckboxIsChecked()
     */
    public function retryDontSeeCheckboxIsChecked($checkbox) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeCheckboxIsChecked', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the given input field or textarea *equals* (i.e. not just contains) the given value.
     * Fields are matched by label text, the "name" attribute, CSS, or XPath.
     *
     * ```php
     * <?php
     * $I->seeInField('Body','Type your comment here');
     * $I->seeInField('form textarea[name=body]','Type your comment here');
     * $I->seeInField('form input[type=hidden]','hidden_value');
     * $I->seeInField('#searchform input','Search');
     * $I->seeInField('//form/*[@name=search]','Search');
     * $I->seeInField(['name' => 'search'], 'Search');
     * ```
     *
     * @param string|array $field
     * @see \Codeception\Lib\InnerBrowser::seeInField()
     */
    public function seeInField($field, $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInField', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the given input field or textarea *equals* (i.e. not just contains) the given value.
     * Fields are matched by label text, the "name" attribute, CSS, or XPath.
     *
     * ```php
     * <?php
     * $I->seeInField('Body','Type your comment here');
     * $I->seeInField('form textarea[name=body]','Type your comment here');
     * $I->seeInField('form input[type=hidden]','hidden_value');
     * $I->seeInField('#searchform input','Search');
     * $I->seeInField('//form/*[@name=search]','Search');
     * $I->seeInField(['name' => 'search'], 'Search');
     * ```
     *
     * @param string|array $field
     * @see \Codeception\Lib\InnerBrowser::seeInField()
     */
    public function canSeeInField($field, $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInField', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the given input field or textarea *equals* (i.e. not just contains) the given value.
     * Fields are matched by label text, the "name" attribute, CSS, or XPath.
     *
     * ```php
     * <?php
     * $I->seeInField('Body','Type your comment here');
     * $I->seeInField('form textarea[name=body]','Type your comment here');
     * $I->seeInField('form input[type=hidden]','hidden_value');
     * $I->seeInField('#searchform input','Search');
     * $I->seeInField('//form/*[@name=search]','Search');
     * $I->seeInField(['name' => 'search'], 'Search');
     * ```
     *
     * @param string|array $field
     * @see \Codeception\Lib\InnerBrowser::seeInField()
     */
    public function tryToSeeInField($field, $value): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInField', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInField and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeInField()
     */
    public function retrySeeInField($field, $value) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInField', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that an input field or textarea doesn't contain the given value.
     * For fuzzy locators, the field is matched by label text, CSS and XPath.
     *
     * ```php
     * <?php
     * $I->dontSeeInField('Body','Type your comment here');
     * $I->dontSeeInField('form textarea[name=body]','Type your comment here');
     * $I->dontSeeInField('form input[type=hidden]','hidden_value');
     * $I->dontSeeInField('#searchform input','Search');
     * $I->dontSeeInField('//form/*[@name=search]','Search');
     * $I->dontSeeInField(['name' => 'search'], 'Search');
     * ```
     * @param string|array $field
     * @see \Codeception\Lib\InnerBrowser::dontSeeInField()
     */
    public function dontSeeInField($field, $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeInField', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that an input field or textarea doesn't contain the given value.
     * For fuzzy locators, the field is matched by label text, CSS and XPath.
     *
     * ```php
     * <?php
     * $I->dontSeeInField('Body','Type your comment here');
     * $I->dontSeeInField('form textarea[name=body]','Type your comment here');
     * $I->dontSeeInField('form input[type=hidden]','hidden_value');
     * $I->dontSeeInField('#searchform input','Search');
     * $I->dontSeeInField('//form/*[@name=search]','Search');
     * $I->dontSeeInField(['name' => 'search'], 'Search');
     * ```
     * @param string|array $field
     * @see \Codeception\Lib\InnerBrowser::dontSeeInField()
     */
    public function cantSeeInField($field, $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeInField', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that an input field or textarea doesn't contain the given value.
     * For fuzzy locators, the field is matched by label text, CSS and XPath.
     *
     * ```php
     * <?php
     * $I->dontSeeInField('Body','Type your comment here');
     * $I->dontSeeInField('form textarea[name=body]','Type your comment here');
     * $I->dontSeeInField('form input[type=hidden]','hidden_value');
     * $I->dontSeeInField('#searchform input','Search');
     * $I->dontSeeInField('//form/*[@name=search]','Search');
     * $I->dontSeeInField(['name' => 'search'], 'Search');
     * ```
     * @param string|array $field
     * @see \Codeception\Lib\InnerBrowser::dontSeeInField()
     */
    public function tryToDontSeeInField($field, $value): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeInField', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeInField and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeInField()
     */
    public function retryDontSeeInField($field, $value) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeInField', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks if the array of form parameters (name => value) are set on the form matched with the
     * passed selector.
     *
     * ```php
     * <?php
     * $I->seeInFormFields('form[name=myform]', [
     *      'input1' => 'value',
     *      'input2' => 'other value',
     * ]);
     * ```
     *
     * For multi-select elements, or to check values of multiple elements with the same name, an
     * array may be passed:
     *
     * ```php
     * <?php
     * $I->seeInFormFields('.form-class', [
     *      'multiselect' => [
     *          'value1',
     *          'value2',
     *      ],
     *      'checkbox[]' => [
     *          'a checked value',
     *          'another checked value',
     *      ],
     * ]);
     * ```
     *
     * Additionally, checkbox values can be checked with a boolean.
     *
     * ```php
     * <?php
     * $I->seeInFormFields('#form-id', [
     *      'checkbox1' => true,        // passes if checked
     *      'checkbox2' => false,       // passes if unchecked
     * ]);
     * ```
     *
     * Pair this with submitForm for quick testing magic.
     *
     * ```php
     * <?php
     * $form = [
     *      'field1' => 'value',
     *      'field2' => 'another value',
     *      'checkbox1' => true,
     *      // ...
     * ];
     * $I->submitForm('//form[@id=my-form]', string $form, 'submitButton');
     * // $I->amOnPage('/path/to/form-page') may be needed
     * $I->seeInFormFields('//form[@id=my-form]', string $form);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInFormFields()
     */
    public function seeInFormFields($formSelector, array $params): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInFormFields', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks if the array of form parameters (name => value) are set on the form matched with the
     * passed selector.
     *
     * ```php
     * <?php
     * $I->seeInFormFields('form[name=myform]', [
     *      'input1' => 'value',
     *      'input2' => 'other value',
     * ]);
     * ```
     *
     * For multi-select elements, or to check values of multiple elements with the same name, an
     * array may be passed:
     *
     * ```php
     * <?php
     * $I->seeInFormFields('.form-class', [
     *      'multiselect' => [
     *          'value1',
     *          'value2',
     *      ],
     *      'checkbox[]' => [
     *          'a checked value',
     *          'another checked value',
     *      ],
     * ]);
     * ```
     *
     * Additionally, checkbox values can be checked with a boolean.
     *
     * ```php
     * <?php
     * $I->seeInFormFields('#form-id', [
     *      'checkbox1' => true,        // passes if checked
     *      'checkbox2' => false,       // passes if unchecked
     * ]);
     * ```
     *
     * Pair this with submitForm for quick testing magic.
     *
     * ```php
     * <?php
     * $form = [
     *      'field1' => 'value',
     *      'field2' => 'another value',
     *      'checkbox1' => true,
     *      // ...
     * ];
     * $I->submitForm('//form[@id=my-form]', string $form, 'submitButton');
     * // $I->amOnPage('/path/to/form-page') may be needed
     * $I->seeInFormFields('//form[@id=my-form]', string $form);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInFormFields()
     */
    public function canSeeInFormFields($formSelector, array $params): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInFormFields', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks if the array of form parameters (name => value) are set on the form matched with the
     * passed selector.
     *
     * ```php
     * <?php
     * $I->seeInFormFields('form[name=myform]', [
     *      'input1' => 'value',
     *      'input2' => 'other value',
     * ]);
     * ```
     *
     * For multi-select elements, or to check values of multiple elements with the same name, an
     * array may be passed:
     *
     * ```php
     * <?php
     * $I->seeInFormFields('.form-class', [
     *      'multiselect' => [
     *          'value1',
     *          'value2',
     *      ],
     *      'checkbox[]' => [
     *          'a checked value',
     *          'another checked value',
     *      ],
     * ]);
     * ```
     *
     * Additionally, checkbox values can be checked with a boolean.
     *
     * ```php
     * <?php
     * $I->seeInFormFields('#form-id', [
     *      'checkbox1' => true,        // passes if checked
     *      'checkbox2' => false,       // passes if unchecked
     * ]);
     * ```
     *
     * Pair this with submitForm for quick testing magic.
     *
     * ```php
     * <?php
     * $form = [
     *      'field1' => 'value',
     *      'field2' => 'another value',
     *      'checkbox1' => true,
     *      // ...
     * ];
     * $I->submitForm('//form[@id=my-form]', string $form, 'submitButton');
     * // $I->amOnPage('/path/to/form-page') may be needed
     * $I->seeInFormFields('//form[@id=my-form]', string $form);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeInFormFields()
     */
    public function tryToSeeInFormFields($formSelector, array $params): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInFormFields', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInFormFields and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeInFormFields()
     */
    public function retrySeeInFormFields($formSelector, array $params) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInFormFields', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks if the array of form parameters (name => value) are not set on the form matched with
     * the passed selector.
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('form[name=myform]', [
     *      'input1' => 'non-existent value',
     *      'input2' => 'other non-existent value',
     * ]);
     * ```
     *
     * To check that an element hasn't been assigned any one of many values, an array can be passed
     * as the value:
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('.form-class', [
     *      'fieldName' => [
     *          'This value shouldn\'t be set',
     *          'And this value shouldn\'t be set',
     *      ],
     * ]);
     * ```
     *
     * Additionally, checkbox values can be checked with a boolean.
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('#form-id', [
     *      'checkbox1' => true,        // fails if checked
     *      'checkbox2' => false,       // fails if unchecked
     * ]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInFormFields()
     */
    public function dontSeeInFormFields($formSelector, array $params): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeInFormFields', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks if the array of form parameters (name => value) are not set on the form matched with
     * the passed selector.
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('form[name=myform]', [
     *      'input1' => 'non-existent value',
     *      'input2' => 'other non-existent value',
     * ]);
     * ```
     *
     * To check that an element hasn't been assigned any one of many values, an array can be passed
     * as the value:
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('.form-class', [
     *      'fieldName' => [
     *          'This value shouldn\'t be set',
     *          'And this value shouldn\'t be set',
     *      ],
     * ]);
     * ```
     *
     * Additionally, checkbox values can be checked with a boolean.
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('#form-id', [
     *      'checkbox1' => true,        // fails if checked
     *      'checkbox2' => false,       // fails if unchecked
     * ]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInFormFields()
     */
    public function cantSeeInFormFields($formSelector, array $params): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeInFormFields', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks if the array of form parameters (name => value) are not set on the form matched with
     * the passed selector.
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('form[name=myform]', [
     *      'input1' => 'non-existent value',
     *      'input2' => 'other non-existent value',
     * ]);
     * ```
     *
     * To check that an element hasn't been assigned any one of many values, an array can be passed
     * as the value:
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('.form-class', [
     *      'fieldName' => [
     *          'This value shouldn\'t be set',
     *          'And this value shouldn\'t be set',
     *      ],
     * ]);
     * ```
     *
     * Additionally, checkbox values can be checked with a boolean.
     *
     * ```php
     * <?php
     * $I->dontSeeInFormFields('#form-id', [
     *      'checkbox1' => true,        // fails if checked
     *      'checkbox2' => false,       // fails if unchecked
     * ]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeInFormFields()
     */
    public function tryToDontSeeInFormFields($formSelector, array $params): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeInFormFields', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeInFormFields and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeInFormFields()
     */
    public function retryDontSeeInFormFields($formSelector, array $params) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeInFormFields', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Submits the given form on the page, with the given form
     * values.  Pass the form field's values as an array in the second
     * parameter.
     *
     * Although this function can be used as a short-hand version of
     * `fillField()`, `selectOption()`, `click()` etc. it has some important
     * differences:
     *
     *  * Only field *names* may be used, not CSS/XPath selectors nor field labels
     *  * If a field is sent to this function that does *not* exist on the page,
     *    it will silently be added to the HTTP request.  This is helpful for testing
     *    some types of forms, but be aware that you will *not* get an exception
     *    like you would if you called `fillField()` or `selectOption()` with
     *    a missing field.
     *
     * Fields that are not provided will be filled by their values from the page,
     * or from any previous calls to `fillField()`, `selectOption()` etc.
     * You don't need to click the 'Submit' button afterwards.
     * This command itself triggers the request to form's action.
     *
     * You can optionally specify which button's value to include
     * in the request with the last parameter (as an alternative to
     * explicitly setting its value in the second parameter), as
     * button values are not otherwise included in the request.
     *
     * Examples:
     *
     * ```php
     * <?php
     * $I->submitForm('#login', [
     *     'login' => 'davert',
     *     'password' => '123456'
     * ]);
     * // or
     * $I->submitForm('#login', [
     *     'login' => 'davert',
     *     'password' => '123456'
     * ], 'submitButtonName');
     *
     * ```
     *
     * For example, given this sample "Sign Up" form:
     *
     * ``` html
     * <form id="userForm">
     *     Login:
     *     <input type="text" name="user[login]" /><br/>
     *     Password:
     *     <input type="password" name="user[password]" /><br/>
     *     Do you agree to our terms?
     *     <input type="checkbox" name="user[agree]" /><br/>
     *     Subscribe to our newsletter?
     *     <input type="checkbox" name="user[newsletter]" value="1" checked="checked" /><br/>
     *     Select pricing plan:
     *     <select name="plan">
     *         <option value="1">Free</option>
     *         <option value="2" selected="selected">Paid</option>
     *     </select>
     *     <input type="submit" name="submitButton" value="Submit" />
     * </form>
     * ```
     *
     * You could write the following to submit it:
     *
     * ```php
     * <?php
     * $I->submitForm(
     *     '#userForm',
     *     [
     *         'user' => [
     *             'login' => 'Davert',
     *             'password' => '123456',
     *             'agree' => true
     *         ]
     *     ],
     *     'submitButton'
     * );
     * ```
     * Note that "2" will be the submitted value for the "plan" field, as it is
     * the selected option.
     *
     * To uncheck the pre-checked checkbox "newsletter", call `$I->uncheckOption(['name' => 'user[newsletter]']);` *before*,
     * then submit the form as shown here (i.e. without the "newsletter" field in the `$params` array).
     *
     * You can also emulate a JavaScript submission by not specifying any
     * buttons in the third parameter to submitForm.
     *
     * ```php
     * <?php
     * $I->submitForm(
     *     '#userForm',
     *     [
     *         'user' => [
     *             'login' => 'Davert',
     *             'password' => '123456',
     *             'agree' => true
     *         ]
     *     ]
     * );
     * ```
     *
     * This function works well when paired with `seeInFormFields()`
     * for quickly testing CRUD interfaces and form validation logic.
     *
     * ```php
     * <?php
     * $form = [
     *      'field1' => 'value',
     *      'field2' => 'another value',
     *      'checkbox1' => true,
     *      // ...
     * ];
     * $I->submitForm('#my-form', $form, 'submitButton');
     * // $I->amOnPage('/path/to/form-page') may be needed
     * $I->seeInFormFields('#my-form', $form);
     * ```
     *
     * Parameter values can be set to arrays for multiple input fields
     * of the same name, or multi-select combo boxes.  For checkboxes,
     * you can use either the string value or boolean `true`/`false` which will
     * be replaced by the checkbox's value in the DOM.
     *
     * ```php
     * <?php
     * $I->submitForm('#my-form', [
     *      'field1' => 'value',
     *      'checkbox' => [
     *          'value of first checkbox',
     *          'value of second checkbox',
     *      ],
     *      'otherCheckboxes' => [
     *          true,
     *          false,
     *          false
     *      ],
     *      'multiselect' => [
     *          'first option value',
     *          'second option value'
     *      ]
     * ]);
     * ```
     *
     * Mixing string and boolean values for a checkbox's value is not supported
     * and may produce unexpected results.
     *
     * Field names ending in `[]` must be passed without the trailing square
     * bracket characters, and must contain an array for its value.  This allows
     * submitting multiple values with the same name, consider:
     *
     * ```php
     * <?php
     * // This will NOT work correctly
     * $I->submitForm('#my-form', [
     *     'field[]' => 'value',
     *     'field[]' => 'another value',  // 'field[]' is already a defined key
     * ]);
     * ```
     *
     * The solution is to pass an array value:
     *
     * ```php
     * <?php
     * // This way both values are submitted
     * $I->submitForm('#my-form', [
     *     'field' => [
     *         'value',
     *         'another value',
     *     ]
     * ]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::submitForm()
     */
    public function submitForm($selector, array $params, ?string $button = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('submitForm', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Submits the given form on the page, with the given form
     * values.  Pass the form field's values as an array in the second
     * parameter.
     *
     * Although this function can be used as a short-hand version of
     * `fillField()`, `selectOption()`, `click()` etc. it has some important
     * differences:
     *
     *  * Only field *names* may be used, not CSS/XPath selectors nor field labels
     *  * If a field is sent to this function that does *not* exist on the page,
     *    it will silently be added to the HTTP request.  This is helpful for testing
     *    some types of forms, but be aware that you will *not* get an exception
     *    like you would if you called `fillField()` or `selectOption()` with
     *    a missing field.
     *
     * Fields that are not provided will be filled by their values from the page,
     * or from any previous calls to `fillField()`, `selectOption()` etc.
     * You don't need to click the 'Submit' button afterwards.
     * This command itself triggers the request to form's action.
     *
     * You can optionally specify which button's value to include
     * in the request with the last parameter (as an alternative to
     * explicitly setting its value in the second parameter), as
     * button values are not otherwise included in the request.
     *
     * Examples:
     *
     * ```php
     * <?php
     * $I->submitForm('#login', [
     *     'login' => 'davert',
     *     'password' => '123456'
     * ]);
     * // or
     * $I->submitForm('#login', [
     *     'login' => 'davert',
     *     'password' => '123456'
     * ], 'submitButtonName');
     *
     * ```
     *
     * For example, given this sample "Sign Up" form:
     *
     * ``` html
     * <form id="userForm">
     *     Login:
     *     <input type="text" name="user[login]" /><br/>
     *     Password:
     *     <input type="password" name="user[password]" /><br/>
     *     Do you agree to our terms?
     *     <input type="checkbox" name="user[agree]" /><br/>
     *     Subscribe to our newsletter?
     *     <input type="checkbox" name="user[newsletter]" value="1" checked="checked" /><br/>
     *     Select pricing plan:
     *     <select name="plan">
     *         <option value="1">Free</option>
     *         <option value="2" selected="selected">Paid</option>
     *     </select>
     *     <input type="submit" name="submitButton" value="Submit" />
     * </form>
     * ```
     *
     * You could write the following to submit it:
     *
     * ```php
     * <?php
     * $I->submitForm(
     *     '#userForm',
     *     [
     *         'user' => [
     *             'login' => 'Davert',
     *             'password' => '123456',
     *             'agree' => true
     *         ]
     *     ],
     *     'submitButton'
     * );
     * ```
     * Note that "2" will be the submitted value for the "plan" field, as it is
     * the selected option.
     *
     * To uncheck the pre-checked checkbox "newsletter", call `$I->uncheckOption(['name' => 'user[newsletter]']);` *before*,
     * then submit the form as shown here (i.e. without the "newsletter" field in the `$params` array).
     *
     * You can also emulate a JavaScript submission by not specifying any
     * buttons in the third parameter to submitForm.
     *
     * ```php
     * <?php
     * $I->submitForm(
     *     '#userForm',
     *     [
     *         'user' => [
     *             'login' => 'Davert',
     *             'password' => '123456',
     *             'agree' => true
     *         ]
     *     ]
     * );
     * ```
     *
     * This function works well when paired with `seeInFormFields()`
     * for quickly testing CRUD interfaces and form validation logic.
     *
     * ```php
     * <?php
     * $form = [
     *      'field1' => 'value',
     *      'field2' => 'another value',
     *      'checkbox1' => true,
     *      // ...
     * ];
     * $I->submitForm('#my-form', $form, 'submitButton');
     * // $I->amOnPage('/path/to/form-page') may be needed
     * $I->seeInFormFields('#my-form', $form);
     * ```
     *
     * Parameter values can be set to arrays for multiple input fields
     * of the same name, or multi-select combo boxes.  For checkboxes,
     * you can use either the string value or boolean `true`/`false` which will
     * be replaced by the checkbox's value in the DOM.
     *
     * ```php
     * <?php
     * $I->submitForm('#my-form', [
     *      'field1' => 'value',
     *      'checkbox' => [
     *          'value of first checkbox',
     *          'value of second checkbox',
     *      ],
     *      'otherCheckboxes' => [
     *          true,
     *          false,
     *          false
     *      ],
     *      'multiselect' => [
     *          'first option value',
     *          'second option value'
     *      ]
     * ]);
     * ```
     *
     * Mixing string and boolean values for a checkbox's value is not supported
     * and may produce unexpected results.
     *
     * Field names ending in `[]` must be passed without the trailing square
     * bracket characters, and must contain an array for its value.  This allows
     * submitting multiple values with the same name, consider:
     *
     * ```php
     * <?php
     * // This will NOT work correctly
     * $I->submitForm('#my-form', [
     *     'field[]' => 'value',
     *     'field[]' => 'another value',  // 'field[]' is already a defined key
     * ]);
     * ```
     *
     * The solution is to pass an array value:
     *
     * ```php
     * <?php
     * // This way both values are submitted
     * $I->submitForm('#my-form', [
     *     'field' => [
     *         'value',
     *         'another value',
     *     ]
     * ]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::submitForm()
     */
    public function tryToSubmitForm($selector, array $params, ?string $button = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('submitForm', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes submitForm and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::submitForm()
     */
    public function retrySubmitForm($selector, array $params, ?string $button = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('submitForm', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Fills a text field or textarea with the given string.
     *
     * ```php
     * <?php
     * $I->fillField("//input[@type='text']", "Hello World!");
     * $I->fillField(['name' => 'email'], 'jon@example.com');
     * ```
     * @see \Codeception\Lib\InnerBrowser::fillField()
     */
    public function fillField($field, $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('fillField', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Fills a text field or textarea with the given string.
     *
     * ```php
     * <?php
     * $I->fillField("//input[@type='text']", "Hello World!");
     * $I->fillField(['name' => 'email'], 'jon@example.com');
     * ```
     * @see \Codeception\Lib\InnerBrowser::fillField()
     */
    public function tryToFillField($field, $value): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('fillField', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes fillField and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::fillField()
     */
    public function retryFillField($field, $value) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('fillField', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Selects an option in a select tag or in radio button group.
     *
     * ```php
     * <?php
     * $I->selectOption('form select[name=account]', 'Premium');
     * $I->selectOption('form input[name=payment]', 'Monthly');
     * $I->selectOption('//form/select[@name=account]', 'Monthly');
     * ```
     *
     * Provide an array for the second argument to select multiple options:
     *
     * ```php
     * <?php
     * $I->selectOption('Which OS do you use?', ['Windows', 'Linux']);
     * ```
     *
     * Or provide an associative array for the second argument to specifically define which selection method should be used:
     *
     * ```php
     * <?php
     * $I->selectOption('Which OS do you use?', ['text' => 'Windows']); // Only search by text 'Windows'
     * $I->selectOption('Which OS do you use?', ['value' => 'windows']); // Only search by value 'windows'
     * ```
     * @see \Codeception\Lib\InnerBrowser::selectOption()
     */
    public function selectOption($select, $option): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('selectOption', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Selects an option in a select tag or in radio button group.
     *
     * ```php
     * <?php
     * $I->selectOption('form select[name=account]', 'Premium');
     * $I->selectOption('form input[name=payment]', 'Monthly');
     * $I->selectOption('//form/select[@name=account]', 'Monthly');
     * ```
     *
     * Provide an array for the second argument to select multiple options:
     *
     * ```php
     * <?php
     * $I->selectOption('Which OS do you use?', ['Windows', 'Linux']);
     * ```
     *
     * Or provide an associative array for the second argument to specifically define which selection method should be used:
     *
     * ```php
     * <?php
     * $I->selectOption('Which OS do you use?', ['text' => 'Windows']); // Only search by text 'Windows'
     * $I->selectOption('Which OS do you use?', ['value' => 'windows']); // Only search by value 'windows'
     * ```
     * @see \Codeception\Lib\InnerBrowser::selectOption()
     */
    public function tryToSelectOption($select, $option): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('selectOption', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes selectOption and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::selectOption()
     */
    public function retrySelectOption($select, $option) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('selectOption', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Ticks a checkbox. For radio buttons, use the `selectOption` method instead.
     *
     * ```php
     * <?php
     * $I->checkOption('#agree');
     * ```
     * @see \Codeception\Lib\InnerBrowser::checkOption()
     */
    public function checkOption($option): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('checkOption', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Ticks a checkbox. For radio buttons, use the `selectOption` method instead.
     *
     * ```php
     * <?php
     * $I->checkOption('#agree');
     * ```
     * @see \Codeception\Lib\InnerBrowser::checkOption()
     */
    public function tryToCheckOption($option): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('checkOption', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes checkOption and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::checkOption()
     */
    public function retryCheckOption($option) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('checkOption', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Unticks a checkbox.
     *
     * ```php
     * <?php
     * $I->uncheckOption('#notify');
     * ```
     * @see \Codeception\Lib\InnerBrowser::uncheckOption()
     */
    public function uncheckOption($option): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('uncheckOption', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Unticks a checkbox.
     *
     * ```php
     * <?php
     * $I->uncheckOption('#notify');
     * ```
     * @see \Codeception\Lib\InnerBrowser::uncheckOption()
     */
    public function tryToUncheckOption($option): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('uncheckOption', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes uncheckOption and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::uncheckOption()
     */
    public function retryUncheckOption($option) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('uncheckOption', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Attaches a file relative to the Codeception `_data` directory to the given file upload field.
     *
     * ```php
     * <?php
     * // file is stored in 'tests/_data/prices.xls'
     * $I->attachFile('input[@type="file"]', 'prices.xls');
     * ```
     * @see \Codeception\Lib\InnerBrowser::attachFile()
     */
    public function attachFile($field, string $filename): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('attachFile', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Attaches a file relative to the Codeception `_data` directory to the given file upload field.
     *
     * ```php
     * <?php
     * // file is stored in 'tests/_data/prices.xls'
     * $I->attachFile('input[@type="file"]', 'prices.xls');
     * ```
     * @see \Codeception\Lib\InnerBrowser::attachFile()
     */
    public function tryToAttachFile($field, string $filename): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('attachFile', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes attachFile and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::attachFile()
     */
    public function retryAttachFile($field, string $filename) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('attachFile', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sends an ajax GET request with the passed parameters.
     * See `sendAjaxPostRequest()`
     * @see \Codeception\Lib\InnerBrowser::sendAjaxGetRequest()
     */
    public function sendAjaxGetRequest(string $uri, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('sendAjaxGetRequest', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Sends an ajax GET request with the passed parameters.
     * See `sendAjaxPostRequest()`
     * @see \Codeception\Lib\InnerBrowser::sendAjaxGetRequest()
     */
    public function tryToSendAjaxGetRequest(string $uri, array $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('sendAjaxGetRequest', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes sendAjaxGetRequest and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::sendAjaxGetRequest()
     */
    public function retrySendAjaxGetRequest(string $uri, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('sendAjaxGetRequest', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sends an ajax POST request with the passed parameters.
     * The appropriate HTTP header is added automatically:
     * `X-Requested-With: XMLHttpRequest`
     * Example:
     * ``` php
     * <?php
     * $I->sendAjaxPostRequest('/add-task', ['task' => 'lorem ipsum']);
     * ```
     * Some frameworks (e.g. Symfony) create field names in the form of an "array":
     * `<input type="text" name="form[task]">`
     * In this case you need to pass the fields like this:
     * ``` php
     * <?php
     * $I->sendAjaxPostRequest('/add-task', ['form' => [
     *     'task' => 'lorem ipsum',
     *     'category' => 'miscellaneous',
     * ]]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::sendAjaxPostRequest()
     */
    public function sendAjaxPostRequest(string $uri, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('sendAjaxPostRequest', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Sends an ajax POST request with the passed parameters.
     * The appropriate HTTP header is added automatically:
     * `X-Requested-With: XMLHttpRequest`
     * Example:
     * ``` php
     * <?php
     * $I->sendAjaxPostRequest('/add-task', ['task' => 'lorem ipsum']);
     * ```
     * Some frameworks (e.g. Symfony) create field names in the form of an "array":
     * `<input type="text" name="form[task]">`
     * In this case you need to pass the fields like this:
     * ``` php
     * <?php
     * $I->sendAjaxPostRequest('/add-task', ['form' => [
     *     'task' => 'lorem ipsum',
     *     'category' => 'miscellaneous',
     * ]]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::sendAjaxPostRequest()
     */
    public function tryToSendAjaxPostRequest(string $uri, array $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('sendAjaxPostRequest', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes sendAjaxPostRequest and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::sendAjaxPostRequest()
     */
    public function retrySendAjaxPostRequest(string $uri, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('sendAjaxPostRequest', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sends an ajax request, using the passed HTTP method.
     * See `sendAjaxPostRequest()`
     * Example:
     * ``` php
     * <?php
     * $I->sendAjaxRequest('PUT', '/posts/7', ['title' => 'new title']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::sendAjaxRequest()
     */
    public function sendAjaxRequest(string $method, string $uri, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('sendAjaxRequest', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Sends an ajax request, using the passed HTTP method.
     * See `sendAjaxPostRequest()`
     * Example:
     * ``` php
     * <?php
     * $I->sendAjaxRequest('PUT', '/posts/7', ['title' => 'new title']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::sendAjaxRequest()
     */
    public function tryToSendAjaxRequest(string $method, string $uri, array $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('sendAjaxRequest', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes sendAjaxRequest and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::sendAjaxRequest()
     */
    public function retrySendAjaxRequest(string $method, string $uri, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('sendAjaxRequest', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Use this method within an [interactive pause](https://codeception.com/docs/02-GettingStarted#Interactive-Pause) to save the HTML source code of the current page.
     *
     * ```php
     * <?php
     * $I->makeHtmlSnapshot('edit_page');
     * // saved to: tests/_output/debug/edit_page.html
     * $I->makeHtmlSnapshot();
     * // saved to: tests/_output/debug/2017-05-26_14-24-11_4b3403665fea6.html
     * ```
     * @see \Codeception\Lib\InnerBrowser::makeHtmlSnapshot()
     */
    public function makeHtmlSnapshot(?string $name = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('makeHtmlSnapshot', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Use this method within an [interactive pause](https://codeception.com/docs/02-GettingStarted#Interactive-Pause) to save the HTML source code of the current page.
     *
     * ```php
     * <?php
     * $I->makeHtmlSnapshot('edit_page');
     * // saved to: tests/_output/debug/edit_page.html
     * $I->makeHtmlSnapshot();
     * // saved to: tests/_output/debug/2017-05-26_14-24-11_4b3403665fea6.html
     * ```
     * @see \Codeception\Lib\InnerBrowser::makeHtmlSnapshot()
     */
    public function tryToMakeHtmlSnapshot(?string $name = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('makeHtmlSnapshot', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes makeHtmlSnapshot and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::makeHtmlSnapshot()
     */
    public function retryMakeHtmlSnapshot(?string $name = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('makeHtmlSnapshot', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Finds and returns the text contents of the given element.
     * If a fuzzy locator is used, the element is found using CSS, XPath,
     * and by matching the full page source by regular expression.
     *
     * ```php
     * <?php
     * $heading = $I->grabTextFrom('h1');
     * $heading = $I->grabTextFrom('descendant-or-self::h1');
     * $value = $I->grabTextFrom('~<input value=(.*?)]~sgi'); // match with a regex
     * ```
     * @see \Codeception\Lib\InnerBrowser::grabTextFrom()
     */
    public function grabTextFrom($cssOrXPathOrRegex): mixed {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabTextFrom', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabTextFrom and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::grabTextFrom()
     */
    public function retryGrabTextFrom($cssOrXPathOrRegex) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabTextFrom', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Returns the value of the given attribute value from the given HTML element. For some attributes, the string `true` is returned instead of their literal value (e.g. `disabled="disabled"` or `required="required"`).
     * Fails if the element is not found. Returns `null` if the attribute is not present on the element.
     *
     * ```php
     * <?php
     * $I->grabAttributeFrom('#tooltip', 'title');
     * ```
     * @see \Codeception\Lib\InnerBrowser::grabAttributeFrom()
     */
    public function grabAttributeFrom($cssOrXpath, string $attribute): mixed {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabAttributeFrom', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabAttributeFrom and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::grabAttributeFrom()
     */
    public function retryGrabAttributeFrom($cssOrXpath, string $attribute) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabAttributeFrom', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Grabs either the text content, or attribute values, of nodes
     * matched by $cssOrXpath and returns them as an array.
     *
     * ```html
     * <a href="#first">First</a>
     * <a href="#second">Second</a>
     * <a href="#third">Third</a>
     * ```
     *
     * ```php
     * <?php
     * // would return ['First', 'Second', 'Third']
     * $aLinkText = $I->grabMultiple('a');
     *
     * // would return ['#first', '#second', '#third']
     * $aLinks = $I->grabMultiple('a', 'href');
     * ```
     *
     * @return string[]
     * @see \Codeception\Lib\InnerBrowser::grabMultiple()
     */
    public function grabMultiple($cssOrXpath, ?string $attribute = NULL): array {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabMultiple', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabMultiple and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::grabMultiple()
     */
    public function retryGrabMultiple($cssOrXpath, ?string $attribute = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabMultiple', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Finds the value for the given form field.
     * If a fuzzy locator is used, the field is found by field name, CSS, and XPath.
     *
     * ```php
     * <?php
     * $name = $I->grabValueFrom('Name');
     * $name = $I->grabValueFrom('input[name=username]');
     * $name = $I->grabValueFrom('descendant-or-self::form/descendant::input[@name = 'username']');
     * $name = $I->grabValueFrom(['name' => 'username']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::grabValueFrom()
     */
    public function grabValueFrom($field): mixed {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabValueFrom', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabValueFrom and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::grabValueFrom()
     */
    public function retryGrabValueFrom($field) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabValueFrom', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sets a cookie with the given name and value.
     * You can set additional cookie params like `domain`, `path`, `expires`, `secure` in array passed as last argument.
     *
     * ```php
     * <?php
     * $I->setCookie('PHPSESSID', 'el4ukv0kqbvoirg7nkp4dncpk3');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::setCookie()
     */
    public function setCookie($name, $val, $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('setCookie', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Sets a cookie with the given name and value.
     * You can set additional cookie params like `domain`, `path`, `expires`, `secure` in array passed as last argument.
     *
     * ```php
     * <?php
     * $I->setCookie('PHPSESSID', 'el4ukv0kqbvoirg7nkp4dncpk3');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::setCookie()
     */
    public function tryToSetCookie($name, $val, $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('setCookie', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes setCookie and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::setCookie()
     */
    public function retrySetCookie($name, $val, $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('setCookie', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Grabs a cookie value.
     * You can set additional cookie params like `domain`, `path` in array passed as last argument.
     * If the cookie is set by an ajax request (XMLHttpRequest), there might be some delay caused by the browser, so try `$I->wait(0.1)`.
     * @see \Codeception\Lib\InnerBrowser::grabCookie()
     */
    public function grabCookie(string $cookie, array $params = []): mixed {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabCookie', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabCookie and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::grabCookie()
     */
    public function retryGrabCookie(string $cookie, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabCookie', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Grabs current page source code.
     *
     * @throws \Codeception\Exception\ModuleException if no page was opened.
     * @return string Current page source code.
     * @see \Codeception\Lib\InnerBrowser::grabPageSource()
     */
    public function grabPageSource(): string {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabPageSource', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabPageSource and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::grabPageSource()
     */
    public function retryGrabPageSource() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabPageSource', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that a cookie with the given name is set.
     * You can set additional cookie params like `domain`, `path` as array passed in last argument.
     *
     * ```php
     * <?php
     * $I->seeCookie('PHPSESSID');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeCookie()
     */
    public function seeCookie($cookie, $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeCookie', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that a cookie with the given name is set.
     * You can set additional cookie params like `domain`, `path` as array passed in last argument.
     *
     * ```php
     * <?php
     * $I->seeCookie('PHPSESSID');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeCookie()
     */
    public function canSeeCookie($cookie, $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeCookie', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that a cookie with the given name is set.
     * You can set additional cookie params like `domain`, `path` as array passed in last argument.
     *
     * ```php
     * <?php
     * $I->seeCookie('PHPSESSID');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeCookie()
     */
    public function tryToSeeCookie($cookie, $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeCookie', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeCookie and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeCookie()
     */
    public function retrySeeCookie($cookie, $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeCookie', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that there isn't a cookie with the given name.
     * You can set additional cookie params like `domain`, `path` as array passed in last argument.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeCookie()
     */
    public function dontSeeCookie($cookie, $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeCookie', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that there isn't a cookie with the given name.
     * You can set additional cookie params like `domain`, `path` as array passed in last argument.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeCookie()
     */
    public function cantSeeCookie($cookie, $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeCookie', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that there isn't a cookie with the given name.
     * You can set additional cookie params like `domain`, `path` as array passed in last argument.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeCookie()
     */
    public function tryToDontSeeCookie($cookie, $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeCookie', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeCookie and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeCookie()
     */
    public function retryDontSeeCookie($cookie, $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeCookie', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Unsets cookie with the given name.
     * You can set additional cookie params like `domain`, `path` in array passed as last argument.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::resetCookie()
     */
    public function resetCookie($cookie, $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('resetCookie', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Unsets cookie with the given name.
     * You can set additional cookie params like `domain`, `path` in array passed as last argument.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::resetCookie()
     */
    public function tryToResetCookie($cookie, $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('resetCookie', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes resetCookie and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::resetCookie()
     */
    public function retryResetCookie($cookie, $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('resetCookie', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the given element exists on the page and is visible.
     * You can also specify expected attributes of this element.
     * Only works if `<html>` tag is present.
     *
     * ```php
     * <?php
     * $I->seeElement('.error');
     * $I->seeElement('//form/input[1]');
     * $I->seeElement('input', ['name' => 'login']);
     * $I->seeElement('input', ['value' => '123456']);
     *
     * // strict locator in first arg, attributes in second
     * $I->seeElement(['css' => 'form input'], ['name' => 'login']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeElement()
     */
    public function seeElement($selector, array $attributes = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeElement', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the given element exists on the page and is visible.
     * You can also specify expected attributes of this element.
     * Only works if `<html>` tag is present.
     *
     * ```php
     * <?php
     * $I->seeElement('.error');
     * $I->seeElement('//form/input[1]');
     * $I->seeElement('input', ['name' => 'login']);
     * $I->seeElement('input', ['value' => '123456']);
     *
     * // strict locator in first arg, attributes in second
     * $I->seeElement(['css' => 'form input'], ['name' => 'login']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeElement()
     */
    public function canSeeElement($selector, array $attributes = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeElement', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the given element exists on the page and is visible.
     * You can also specify expected attributes of this element.
     * Only works if `<html>` tag is present.
     *
     * ```php
     * <?php
     * $I->seeElement('.error');
     * $I->seeElement('//form/input[1]');
     * $I->seeElement('input', ['name' => 'login']);
     * $I->seeElement('input', ['value' => '123456']);
     *
     * // strict locator in first arg, attributes in second
     * $I->seeElement(['css' => 'form input'], ['name' => 'login']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeElement()
     */
    public function tryToSeeElement($selector, array $attributes = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeElement', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeElement and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeElement()
     */
    public function retrySeeElement($selector, array $attributes = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeElement', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the given element is invisible or not present on the page.
     * You can also specify expected attributes of this element.
     *
     * ```php
     * <?php
     * $I->dontSeeElement('.error');
     * $I->dontSeeElement('//form/input[1]');
     * $I->dontSeeElement('input', ['name' => 'login']);
     * $I->dontSeeElement('input', ['value' => '123456']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeElement()
     */
    public function dontSeeElement($selector, array $attributes = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeElement', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the given element is invisible or not present on the page.
     * You can also specify expected attributes of this element.
     *
     * ```php
     * <?php
     * $I->dontSeeElement('.error');
     * $I->dontSeeElement('//form/input[1]');
     * $I->dontSeeElement('input', ['name' => 'login']);
     * $I->dontSeeElement('input', ['value' => '123456']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeElement()
     */
    public function cantSeeElement($selector, array $attributes = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeElement', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the given element is invisible or not present on the page.
     * You can also specify expected attributes of this element.
     *
     * ```php
     * <?php
     * $I->dontSeeElement('.error');
     * $I->dontSeeElement('//form/input[1]');
     * $I->dontSeeElement('input', ['name' => 'login']);
     * $I->dontSeeElement('input', ['value' => '123456']);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeElement()
     */
    public function tryToDontSeeElement($selector, array $attributes = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeElement', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeElement and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeElement()
     */
    public function retryDontSeeElement($selector, array $attributes = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeElement', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that there are a certain number of elements matched by the given locator on the page.
     *
     * ```php
     * <?php
     * $I->seeNumberOfElements('tr', 10);
     * $I->seeNumberOfElements('tr', [0,10]); // between 0 and 10 elements
     * ```
     *
     * @param int|int[] $expected
     * @see \Codeception\Lib\InnerBrowser::seeNumberOfElements()
     */
    public function seeNumberOfElements($selector, $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeNumberOfElements', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that there are a certain number of elements matched by the given locator on the page.
     *
     * ```php
     * <?php
     * $I->seeNumberOfElements('tr', 10);
     * $I->seeNumberOfElements('tr', [0,10]); // between 0 and 10 elements
     * ```
     *
     * @param int|int[] $expected
     * @see \Codeception\Lib\InnerBrowser::seeNumberOfElements()
     */
    public function canSeeNumberOfElements($selector, $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeNumberOfElements', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that there are a certain number of elements matched by the given locator on the page.
     *
     * ```php
     * <?php
     * $I->seeNumberOfElements('tr', 10);
     * $I->seeNumberOfElements('tr', [0,10]); // between 0 and 10 elements
     * ```
     *
     * @param int|int[] $expected
     * @see \Codeception\Lib\InnerBrowser::seeNumberOfElements()
     */
    public function tryToSeeNumberOfElements($selector, $expected): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeNumberOfElements', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeNumberOfElements and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeNumberOfElements()
     */
    public function retrySeeNumberOfElements($selector, $expected) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeNumberOfElements', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the given option is selected.
     *
     * ```php
     * <?php
     * $I->seeOptionIsSelected('#form input[name=payment]', 'Visa');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeOptionIsSelected()
     */
    public function seeOptionIsSelected($selector, $optionText) {
        return $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeOptionIsSelected', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the given option is selected.
     *
     * ```php
     * <?php
     * $I->seeOptionIsSelected('#form input[name=payment]', 'Visa');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeOptionIsSelected()
     */
    public function canSeeOptionIsSelected($selector, $optionText) {
        return $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeOptionIsSelected', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the given option is selected.
     *
     * ```php
     * <?php
     * $I->seeOptionIsSelected('#form input[name=payment]', 'Visa');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeOptionIsSelected()
     */
    public function tryToSeeOptionIsSelected($selector, $optionText): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeOptionIsSelected', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeOptionIsSelected and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeOptionIsSelected()
     */
    public function retrySeeOptionIsSelected($selector, $optionText) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeOptionIsSelected', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the given option is not selected.
     *
     * ```php
     * <?php
     * $I->dontSeeOptionIsSelected('#form input[name=payment]', 'Visa');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeOptionIsSelected()
     */
    public function dontSeeOptionIsSelected($selector, $optionText) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeOptionIsSelected', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the given option is not selected.
     *
     * ```php
     * <?php
     * $I->dontSeeOptionIsSelected('#form input[name=payment]', 'Visa');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeOptionIsSelected()
     */
    public function cantSeeOptionIsSelected($selector, $optionText) {
        return $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeOptionIsSelected', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the given option is not selected.
     *
     * ```php
     * <?php
     * $I->dontSeeOptionIsSelected('#form input[name=payment]', 'Visa');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeOptionIsSelected()
     */
    public function tryToDontSeeOptionIsSelected($selector, $optionText): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeOptionIsSelected', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeOptionIsSelected and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeOptionIsSelected()
     */
    public function retryDontSeeOptionIsSelected($selector, $optionText) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeOptionIsSelected', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that current page has 404 response status code.
     * @see \Codeception\Lib\InnerBrowser::seePageNotFound()
     */
    public function seePageNotFound(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seePageNotFound', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that current page has 404 response status code.
     * @see \Codeception\Lib\InnerBrowser::seePageNotFound()
     */
    public function canSeePageNotFound(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seePageNotFound', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that current page has 404 response status code.
     * @see \Codeception\Lib\InnerBrowser::seePageNotFound()
     */
    public function tryToSeePageNotFound(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seePageNotFound', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seePageNotFound and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seePageNotFound()
     */
    public function retrySeePageNotFound() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seePageNotFound', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that response code is equal to value provided.
     *
     * ```php
     * <?php
     * $I->seeResponseCodeIs(200);
     *
     * // recommended \Codeception\Util\HttpCode
     * $I->seeResponseCodeIs(\Codeception\Util\HttpCode::OK);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIs()
     */
    public function seeResponseCodeIs(int $code): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeResponseCodeIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that response code is equal to value provided.
     *
     * ```php
     * <?php
     * $I->seeResponseCodeIs(200);
     *
     * // recommended \Codeception\Util\HttpCode
     * $I->seeResponseCodeIs(\Codeception\Util\HttpCode::OK);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIs()
     */
    public function canSeeResponseCodeIs(int $code): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeResponseCodeIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that response code is equal to value provided.
     *
     * ```php
     * <?php
     * $I->seeResponseCodeIs(200);
     *
     * // recommended \Codeception\Util\HttpCode
     * $I->seeResponseCodeIs(\Codeception\Util\HttpCode::OK);
     * ```
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIs()
     */
    public function tryToSeeResponseCodeIs(int $code): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeResponseCodeIs', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeResponseCodeIs and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIs()
     */
    public function retrySeeResponseCodeIs(int $code) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeResponseCodeIs', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that response code is between a certain range. Between actually means [from <= CODE <= to]
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsBetween()
     */
    public function seeResponseCodeIsBetween(int $from, int $to): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeResponseCodeIsBetween', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that response code is between a certain range. Between actually means [from <= CODE <= to]
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsBetween()
     */
    public function canSeeResponseCodeIsBetween(int $from, int $to): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeResponseCodeIsBetween', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that response code is between a certain range. Between actually means [from <= CODE <= to]
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsBetween()
     */
    public function tryToSeeResponseCodeIsBetween(int $from, int $to): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeResponseCodeIsBetween', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeResponseCodeIsBetween and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsBetween()
     */
    public function retrySeeResponseCodeIsBetween(int $from, int $to) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeResponseCodeIsBetween', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that response code is equal to value provided.
     *
     * ```php
     * <?php
     * $I->dontSeeResponseCodeIs(200);
     *
     * // recommended \Codeception\Util\HttpCode
     * $I->dontSeeResponseCodeIs(\Codeception\Util\HttpCode::OK);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeResponseCodeIs()
     */
    public function dontSeeResponseCodeIs(int $code): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeResponseCodeIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that response code is equal to value provided.
     *
     * ```php
     * <?php
     * $I->dontSeeResponseCodeIs(200);
     *
     * // recommended \Codeception\Util\HttpCode
     * $I->dontSeeResponseCodeIs(\Codeception\Util\HttpCode::OK);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeResponseCodeIs()
     */
    public function cantSeeResponseCodeIs(int $code): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeResponseCodeIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that response code is equal to value provided.
     *
     * ```php
     * <?php
     * $I->dontSeeResponseCodeIs(200);
     *
     * // recommended \Codeception\Util\HttpCode
     * $I->dontSeeResponseCodeIs(\Codeception\Util\HttpCode::OK);
     * ```
     * @see \Codeception\Lib\InnerBrowser::dontSeeResponseCodeIs()
     */
    public function tryToDontSeeResponseCodeIs(int $code): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeResponseCodeIs', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeResponseCodeIs and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeResponseCodeIs()
     */
    public function retryDontSeeResponseCodeIs(int $code) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeResponseCodeIs', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the response code 2xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsSuccessful()
     */
    public function seeResponseCodeIsSuccessful(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeResponseCodeIsSuccessful', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the response code 2xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsSuccessful()
     */
    public function canSeeResponseCodeIsSuccessful(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeResponseCodeIsSuccessful', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the response code 2xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsSuccessful()
     */
    public function tryToSeeResponseCodeIsSuccessful(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeResponseCodeIsSuccessful', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeResponseCodeIsSuccessful and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsSuccessful()
     */
    public function retrySeeResponseCodeIsSuccessful() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeResponseCodeIsSuccessful', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the response code 3xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsRedirection()
     */
    public function seeResponseCodeIsRedirection(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeResponseCodeIsRedirection', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the response code 3xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsRedirection()
     */
    public function canSeeResponseCodeIsRedirection(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeResponseCodeIsRedirection', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the response code 3xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsRedirection()
     */
    public function tryToSeeResponseCodeIsRedirection(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeResponseCodeIsRedirection', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeResponseCodeIsRedirection and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsRedirection()
     */
    public function retrySeeResponseCodeIsRedirection() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeResponseCodeIsRedirection', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the response code is 4xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsClientError()
     */
    public function seeResponseCodeIsClientError(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeResponseCodeIsClientError', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the response code is 4xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsClientError()
     */
    public function canSeeResponseCodeIsClientError(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeResponseCodeIsClientError', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the response code is 4xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsClientError()
     */
    public function tryToSeeResponseCodeIsClientError(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeResponseCodeIsClientError', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeResponseCodeIsClientError and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsClientError()
     */
    public function retrySeeResponseCodeIsClientError() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeResponseCodeIsClientError', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the response code is 5xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsServerError()
     */
    public function seeResponseCodeIsServerError(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeResponseCodeIsServerError', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the response code is 5xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsServerError()
     */
    public function canSeeResponseCodeIsServerError(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeResponseCodeIsServerError', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the response code is 5xx
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsServerError()
     */
    public function tryToSeeResponseCodeIsServerError(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeResponseCodeIsServerError', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeResponseCodeIsServerError and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeResponseCodeIsServerError()
     */
    public function retrySeeResponseCodeIsServerError() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeResponseCodeIsServerError', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the page title contains the given string.
     *
     * ```php
     * <?php
     * $I->seeInTitle('Blog - Post #1');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeInTitle()
     */
    public function seeInTitle($title) {
        return $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInTitle', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the page title contains the given string.
     *
     * ```php
     * <?php
     * $I->seeInTitle('Blog - Post #1');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeInTitle()
     */
    public function canSeeInTitle($title) {
        return $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInTitle', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the page title contains the given string.
     *
     * ```php
     * <?php
     * $I->seeInTitle('Blog - Post #1');
     * ```
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::seeInTitle()
     */
    public function tryToSeeInTitle($title): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInTitle', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInTitle and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::seeInTitle()
     */
    public function retrySeeInTitle($title) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInTitle', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the page title does not contain the given string.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeInTitle()
     */
    public function dontSeeInTitle($title) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeInTitle', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the page title does not contain the given string.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeInTitle()
     */
    public function cantSeeInTitle($title) {
        return $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeInTitle', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the page title does not contain the given string.
     *
     * @return mixed|void
     * @see \Codeception\Lib\InnerBrowser::dontSeeInTitle()
     */
    public function tryToDontSeeInTitle($title): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeInTitle', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeInTitle and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::dontSeeInTitle()
     */
    public function retryDontSeeInTitle($title) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeInTitle', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Switch to iframe or frame on the page.
     *
     * Example:
     * ``` html
     * <iframe name="another_frame" src="http://example.com">
     * ```
     *
     * ``` php
     * <?php
     * # switch to iframe
     * $I->switchToIframe("another_frame");
     * ```
     * @see \Codeception\Lib\InnerBrowser::switchToIframe()
     */
    public function switchToIframe(string $name): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('switchToIframe', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Switch to iframe or frame on the page.
     *
     * Example:
     * ``` html
     * <iframe name="another_frame" src="http://example.com">
     * ```
     *
     * ``` php
     * <?php
     * # switch to iframe
     * $I->switchToIframe("another_frame");
     * ```
     * @see \Codeception\Lib\InnerBrowser::switchToIframe()
     */
    public function tryToSwitchToIframe(string $name): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('switchToIframe', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes switchToIframe and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::switchToIframe()
     */
    public function retrySwitchToIframe(string $name) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('switchToIframe', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Moves back in history.
     *
     * @param int $numberOfSteps (default value 1)
     * @see \Codeception\Lib\InnerBrowser::moveBack()
     */
    public function moveBack(int $numberOfSteps = 1): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('moveBack', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Moves back in history.
     *
     * @param int $numberOfSteps (default value 1)
     * @see \Codeception\Lib\InnerBrowser::moveBack()
     */
    public function tryToMoveBack(int $numberOfSteps = 1): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('moveBack', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes moveBack and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::moveBack()
     */
    public function retryMoveBack(int $numberOfSteps = 1) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('moveBack', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sets SERVER parameters valid for all next requests.
     * this will remove old ones.
     *
     * ```php
     * $I->setServerParameters([]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::setServerParameters()
     */
    public function setServerParameters(array $params): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('setServerParameters', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Sets SERVER parameters valid for all next requests.
     * this will remove old ones.
     *
     * ```php
     * $I->setServerParameters([]);
     * ```
     * @see \Codeception\Lib\InnerBrowser::setServerParameters()
     */
    public function tryToSetServerParameters(array $params): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('setServerParameters', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes setServerParameters and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::setServerParameters()
     */
    public function retrySetServerParameters(array $params) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('setServerParameters', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sets SERVER parameter valid for all next requests.
     *
     * ```php
     * $I->haveServerParameter('name', 'value');
     * ```
     * @see \Codeception\Lib\InnerBrowser::haveServerParameter()
     */
    public function haveServerParameter(string $name, string $value): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('haveServerParameter', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Prevents automatic redirects to be followed by the client.
     *
     * ```php
     * <?php
     * $I->stopFollowingRedirects();
     * ```
     * @see \Codeception\Lib\InnerBrowser::stopFollowingRedirects()
     */
    public function stopFollowingRedirects(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('stopFollowingRedirects', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Prevents automatic redirects to be followed by the client.
     *
     * ```php
     * <?php
     * $I->stopFollowingRedirects();
     * ```
     * @see \Codeception\Lib\InnerBrowser::stopFollowingRedirects()
     */
    public function tryToStopFollowingRedirects(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('stopFollowingRedirects', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes stopFollowingRedirects and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::stopFollowingRedirects()
     */
    public function retryStopFollowingRedirects() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('stopFollowingRedirects', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Enables automatic redirects to be followed by the client.
     *
     * ```php
     * <?php
     * $I->startFollowingRedirects();
     * ```
     * @see \Codeception\Lib\InnerBrowser::startFollowingRedirects()
     */
    public function startFollowingRedirects(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('startFollowingRedirects', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Enables automatic redirects to be followed by the client.
     *
     * ```php
     * <?php
     * $I->startFollowingRedirects();
     * ```
     * @see \Codeception\Lib\InnerBrowser::startFollowingRedirects()
     */
    public function tryToStartFollowingRedirects(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('startFollowingRedirects', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes startFollowingRedirects and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::startFollowingRedirects()
     */
    public function retryStartFollowingRedirects() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('startFollowingRedirects', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Follow pending redirect if there is one.
     *
     * ```php
     * <?php
     * $I->followRedirect();
     * ```
     * @see \Codeception\Lib\InnerBrowser::followRedirect()
     */
    public function followRedirect(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('followRedirect', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Follow pending redirect if there is one.
     *
     * ```php
     * <?php
     * $I->followRedirect();
     * ```
     * @see \Codeception\Lib\InnerBrowser::followRedirect()
     */
    public function tryToFollowRedirect(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('followRedirect', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes followRedirect and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::followRedirect()
     */
    public function retryFollowRedirect() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('followRedirect', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Sets the maximum number of redirects that the Client can follow.
     *
     * ```php
     * <?php
     * $I->setMaxRedirects(2);
     * ```
     * @see \Codeception\Lib\InnerBrowser::setMaxRedirects()
     */
    public function setMaxRedirects(int $maxRedirects): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('setMaxRedirects', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Sets the maximum number of redirects that the Client can follow.
     *
     * ```php
     * <?php
     * $I->setMaxRedirects(2);
     * ```
     * @see \Codeception\Lib\InnerBrowser::setMaxRedirects()
     */
    public function tryToSetMaxRedirects(int $maxRedirects): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('setMaxRedirects', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes setMaxRedirects and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Lib\InnerBrowser::setMaxRedirects()
     */
    public function retrySetMaxRedirects(int $maxRedirects) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('setMaxRedirects', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Reboot client's kernel.
     * Can be used to manually reboot kernel when 'rebootable_client' => false
     *
     * ```php
     * <?php
     *
     * // Perform some requests
     *
     * $I->rebootClientKernel();
     *
     * // Perform other requests
     *
     * ```
     * @see \Codeception\Module\Symfony::rebootClientKernel()
     */
    public function rebootClientKernel(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('rebootClientKernel', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Reboot client's kernel.
     * Can be used to manually reboot kernel when 'rebootable_client' => false
     *
     * ```php
     * <?php
     *
     * // Perform some requests
     *
     * $I->rebootClientKernel();
     *
     * // Perform other requests
     *
     * ```
     * @see \Codeception\Module\Symfony::rebootClientKernel()
     */
    public function tryToRebootClientKernel(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('rebootClientKernel', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes rebootClientKernel and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::rebootClientKernel()
     */
    public function retryRebootClientKernel() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('rebootClientKernel', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that a page is available.
     * By default, it checks the current page, specify the `$url` parameter to change it.
     *
     * ```php
     * <?php
     * $I->amOnPage('/dashboard');
     * $I->seePageIsAvailable();
     *
     * $I->seePageIsAvailable('/dashboard'); // Same as above
     * ```
     *
     * @param string|null $url
     * @see \Codeception\Module\Symfony::seePageIsAvailable()
     */
    public function seePageIsAvailable(?string $url = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seePageIsAvailable', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that a page is available.
     * By default, it checks the current page, specify the `$url` parameter to change it.
     *
     * ```php
     * <?php
     * $I->amOnPage('/dashboard');
     * $I->seePageIsAvailable();
     *
     * $I->seePageIsAvailable('/dashboard'); // Same as above
     * ```
     *
     * @param string|null $url
     * @see \Codeception\Module\Symfony::seePageIsAvailable()
     */
    public function canSeePageIsAvailable(?string $url = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seePageIsAvailable', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that a page is available.
     * By default, it checks the current page, specify the `$url` parameter to change it.
     *
     * ```php
     * <?php
     * $I->amOnPage('/dashboard');
     * $I->seePageIsAvailable();
     *
     * $I->seePageIsAvailable('/dashboard'); // Same as above
     * ```
     *
     * @param string|null $url
     * @see \Codeception\Module\Symfony::seePageIsAvailable()
     */
    public function tryToSeePageIsAvailable(?string $url = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seePageIsAvailable', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seePageIsAvailable and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seePageIsAvailable()
     */
    public function retrySeePageIsAvailable(?string $url = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seePageIsAvailable', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Goes to a page and check that it redirects to another.
     *
     * ```php
     * <?php
     * $I->seePageRedirectsTo('/admin', '/login');
     * ```
     * @see \Codeception\Module\Symfony::seePageRedirectsTo()
     */
    public function seePageRedirectsTo(string $page, string $redirectsTo): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seePageRedirectsTo', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Goes to a page and check that it redirects to another.
     *
     * ```php
     * <?php
     * $I->seePageRedirectsTo('/admin', '/login');
     * ```
     * @see \Codeception\Module\Symfony::seePageRedirectsTo()
     */
    public function canSeePageRedirectsTo(string $page, string $redirectsTo): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seePageRedirectsTo', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Goes to a page and check that it redirects to another.
     *
     * ```php
     * <?php
     * $I->seePageRedirectsTo('/admin', '/login');
     * ```
     * @see \Codeception\Module\Symfony::seePageRedirectsTo()
     */
    public function tryToSeePageRedirectsTo(string $page, string $redirectsTo): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seePageRedirectsTo', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seePageRedirectsTo and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seePageRedirectsTo()
     */
    public function retrySeePageRedirectsTo(string $page, string $redirectsTo) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seePageRedirectsTo', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Submit a form specifying the form name only once.
     *
     * Use this function instead of [`$I->submitForm()`](#submitForm) to avoid repeating the form name in the field selectors.
     * If you customized the names of the field selectors use `$I->submitForm()` for full control.
     *
     * ```php
     * <?php
     * $I->submitSymfonyForm('login_form', [
     *     '[email]'    => 'john_doe@example.com',
     *     '[password]' => 'secretForest'
     * ]);
     * ```
     *
     * @param string $name The `name` attribute of the `<form>` (you cannot use an array as selector here)
     * @param string[] $fields
     * @see \Codeception\Module\Symfony::submitSymfonyForm()
     */
    public function submitSymfonyForm(string $name, array $fields): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('submitSymfonyForm', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Submit a form specifying the form name only once.
     *
     * Use this function instead of [`$I->submitForm()`](#submitForm) to avoid repeating the form name in the field selectors.
     * If you customized the names of the field selectors use `$I->submitForm()` for full control.
     *
     * ```php
     * <?php
     * $I->submitSymfonyForm('login_form', [
     *     '[email]'    => 'john_doe@example.com',
     *     '[password]' => 'secretForest'
     * ]);
     * ```
     *
     * @param string $name The `name` attribute of the `<form>` (you cannot use an array as selector here)
     * @param string[] $fields
     * @see \Codeception\Module\Symfony::submitSymfonyForm()
     */
    public function tryToSubmitSymfonyForm(string $name, array $fields): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('submitSymfonyForm', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes submitSymfonyForm and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::submitSymfonyForm()
     */
    public function retrySubmitSymfonyForm(string $name, array $fields) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('submitSymfonyForm', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Run Symfony console command, grab response and return as string.
     * Recommended to use for integration or functional testing.
     *
     * ```php
     * <?php
     * $result = $I->runSymfonyConsoleCommand('hello:world', ['arg' => 'argValue', 'opt1' => 'optValue'], ['input']);
     * ```
     *
     * @param string $command          The console command to execute
     * @param array  $parameters       Parameters (arguments and options) to pass to the command
     * @param array  $consoleInputs    Console inputs (e.g. used for interactive questions)
     * @param int    $expectedExitCode The expected exit code of the command
     * @return string Returns the console output of the command
     * @see \Codeception\Module\Symfony::runSymfonyConsoleCommand()
     */
    public function runSymfonyConsoleCommand(string $command, array $parameters = [], array $consoleInputs = [], int $expectedExitCode = 0): string {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('runSymfonyConsoleCommand', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Run Symfony console command, grab response and return as string.
     * Recommended to use for integration or functional testing.
     *
     * ```php
     * <?php
     * $result = $I->runSymfonyConsoleCommand('hello:world', ['arg' => 'argValue', 'opt1' => 'optValue'], ['input']);
     * ```
     *
     * @param string $command          The console command to execute
     * @param array  $parameters       Parameters (arguments and options) to pass to the command
     * @param array  $consoleInputs    Console inputs (e.g. used for interactive questions)
     * @param int    $expectedExitCode The expected exit code of the command
     * @return string Returns the console output of the command
     * @see \Codeception\Module\Symfony::runSymfonyConsoleCommand()
     */
    public function tryToRunSymfonyConsoleCommand(string $command, array $parameters = [], array $consoleInputs = [], int $expectedExitCode = 0): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('runSymfonyConsoleCommand', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes runSymfonyConsoleCommand and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::runSymfonyConsoleCommand()
     */
    public function retryRunSymfonyConsoleCommand(string $command, array $parameters = [], array $consoleInputs = [], int $expectedExitCode = 0) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('runSymfonyConsoleCommand', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Retrieves number of records from database
     * 'id' is the default search parameter.
     *
     * ```php
     * <?php
     * $I->grabNumRecords('User::class', ['name' => 'davert']);
     * ```
     *
     * @param string $entityClass The entity class
     * @param array  $criteria    Optional query criteria
     * @see \Codeception\Module\Symfony::grabNumRecords()
     */
    public function grabNumRecords(string $entityClass, array $criteria = []): int {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabNumRecords', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabNumRecords and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::grabNumRecords()
     */
    public function retryGrabNumRecords(string $entityClass, array $criteria = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabNumRecords', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Grab a Doctrine entity repository.
     * Works with objects, entities, repositories, and repository interfaces.
     *
     * ```php
     * <?php
     * $I->grabRepository($user);
     * $I->grabRepository(User::class);
     * $I->grabRepository(UserRepository::class);
     * $I->grabRepository(UserRepositoryInterface::class);
     * ```
     * @see \Codeception\Module\Symfony::grabRepository()
     */
    public function grabRepository(object|string $mixed): ?\Doctrine\ORM\EntityRepository {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabRepository', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabRepository and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::grabRepository()
     */
    public function retryGrabRepository(object|string $mixed) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabRepository', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that number of given records were found in database.
     * 'id' is the default search parameter.
     *
     * ```php
     * <?php
     * $I->seeNumRecords(1, User::class, ['name' => 'davert']);
     * $I->seeNumRecords(80, User::class);
     * ```
     *
     * @param int $expectedNum Expected number of records
     * @param string $className A doctrine entity
     * @param array $criteria Optional query criteria
     * @see \Codeception\Module\Symfony::seeNumRecords()
     */
    public function seeNumRecords(int $expectedNum, string $className, array $criteria = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeNumRecords', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that number of given records were found in database.
     * 'id' is the default search parameter.
     *
     * ```php
     * <?php
     * $I->seeNumRecords(1, User::class, ['name' => 'davert']);
     * $I->seeNumRecords(80, User::class);
     * ```
     *
     * @param int $expectedNum Expected number of records
     * @param string $className A doctrine entity
     * @param array $criteria Optional query criteria
     * @see \Codeception\Module\Symfony::seeNumRecords()
     */
    public function canSeeNumRecords(int $expectedNum, string $className, array $criteria = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeNumRecords', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that number of given records were found in database.
     * 'id' is the default search parameter.
     *
     * ```php
     * <?php
     * $I->seeNumRecords(1, User::class, ['name' => 'davert']);
     * $I->seeNumRecords(80, User::class);
     * ```
     *
     * @param int $expectedNum Expected number of records
     * @param string $className A doctrine entity
     * @param array $criteria Optional query criteria
     * @see \Codeception\Module\Symfony::seeNumRecords()
     */
    public function tryToSeeNumRecords(int $expectedNum, string $className, array $criteria = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeNumRecords', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeNumRecords and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeNumRecords()
     */
    public function retrySeeNumRecords(int $expectedNum, string $className, array $criteria = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeNumRecords', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that there were no events during the test.
     * Both regular and orphan events are checked.
     *
     * ```php
     *  <?php
     *  $I->dontSeeEvent();
     *  $I->dontSeeEvent('App\MyEvent');
     *  $I->dontSeeEvent(['App\MyEvent', 'App\MyOtherEvent']);
     *  ```
     *
     * @param string|string[]|null $expected
     * @see \Codeception\Module\Symfony::dontSeeEvent()
     */
    public function dontSeeEvent(array|string|null $expected = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that there were no events during the test.
     * Both regular and orphan events are checked.
     *
     * ```php
     *  <?php
     *  $I->dontSeeEvent();
     *  $I->dontSeeEvent('App\MyEvent');
     *  $I->dontSeeEvent(['App\MyEvent', 'App\MyOtherEvent']);
     *  ```
     *
     * @param string|string[]|null $expected
     * @see \Codeception\Module\Symfony::dontSeeEvent()
     */
    public function cantSeeEvent(array|string|null $expected = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that there were no events during the test.
     * Both regular and orphan events are checked.
     *
     * ```php
     *  <?php
     *  $I->dontSeeEvent();
     *  $I->dontSeeEvent('App\MyEvent');
     *  $I->dontSeeEvent(['App\MyEvent', 'App\MyOtherEvent']);
     *  ```
     *
     * @param string|string[]|null $expected
     * @see \Codeception\Module\Symfony::dontSeeEvent()
     */
    public function tryToDontSeeEvent(array|string|null $expected = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeEvent', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeEvent and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeEvent()
     */
    public function retryDontSeeEvent(array|string|null $expected = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeEvent', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that one or more event listeners were not called during the test.
     *
     * ```php
     * <?php
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener');
     * $I->dontSeeEventListenerIsCalled(['App\MyEventListener', 'App\MyOtherEventListener']);
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener', 'my.event);
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener', ['my.event', 'my.other.event']);
     * ```
     *
     * @param class-string|class-string[] $expected
     * @param string|string[] $events
     * @see \Codeception\Module\Symfony::dontSeeEventListenerIsCalled()
     */
    public function dontSeeEventListenerIsCalled(object|array|string $expected, array|string $events = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeEventListenerIsCalled', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that one or more event listeners were not called during the test.
     *
     * ```php
     * <?php
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener');
     * $I->dontSeeEventListenerIsCalled(['App\MyEventListener', 'App\MyOtherEventListener']);
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener', 'my.event);
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener', ['my.event', 'my.other.event']);
     * ```
     *
     * @param class-string|class-string[] $expected
     * @param string|string[] $events
     * @see \Codeception\Module\Symfony::dontSeeEventListenerIsCalled()
     */
    public function cantSeeEventListenerIsCalled(object|array|string $expected, array|string $events = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeEventListenerIsCalled', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that one or more event listeners were not called during the test.
     *
     * ```php
     * <?php
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener');
     * $I->dontSeeEventListenerIsCalled(['App\MyEventListener', 'App\MyOtherEventListener']);
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener', 'my.event);
     * $I->dontSeeEventListenerIsCalled('App\MyEventListener', ['my.event', 'my.other.event']);
     * ```
     *
     * @param class-string|class-string[] $expected
     * @param string|string[] $events
     * @see \Codeception\Module\Symfony::dontSeeEventListenerIsCalled()
     */
    public function tryToDontSeeEventListenerIsCalled(object|array|string $expected, array|string $events = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeEventListenerIsCalled', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeEventListenerIsCalled and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeEventListenerIsCalled()
     */
    public function retryDontSeeEventListenerIsCalled(object|array|string $expected, array|string $events = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeEventListenerIsCalled', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that one or more event listeners were not called during the test.
     *
     * ```php
     * <?php
     * $I->dontSeeEventTriggered('App\MyEvent');
     * $I->dontSeeEventTriggered(new App\Events\MyEvent());
     * $I->dontSeeEventTriggered(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param object|string|string[] $expected
     * @deprecated Use `dontSeeEventListenerIsCalled` instead.
     * @see \Codeception\Module\Symfony::dontSeeEventTriggered()
     */
    public function dontSeeEventTriggered(object|array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeEventTriggered', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that one or more event listeners were not called during the test.
     *
     * ```php
     * <?php
     * $I->dontSeeEventTriggered('App\MyEvent');
     * $I->dontSeeEventTriggered(new App\Events\MyEvent());
     * $I->dontSeeEventTriggered(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param object|string|string[] $expected
     * @deprecated Use `dontSeeEventListenerIsCalled` instead.
     * @see \Codeception\Module\Symfony::dontSeeEventTriggered()
     */
    public function cantSeeEventTriggered(object|array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeEventTriggered', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that one or more event listeners were not called during the test.
     *
     * ```php
     * <?php
     * $I->dontSeeEventTriggered('App\MyEvent');
     * $I->dontSeeEventTriggered(new App\Events\MyEvent());
     * $I->dontSeeEventTriggered(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param object|string|string[] $expected
     * @deprecated Use `dontSeeEventListenerIsCalled` instead.
     * @see \Codeception\Module\Symfony::dontSeeEventTriggered()
     */
    public function tryToDontSeeEventTriggered(object|array|string $expected): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeEventTriggered', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeEventTriggered and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeEventTriggered()
     */
    public function retryDontSeeEventTriggered(object|array|string $expected) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeEventTriggered', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that there were no orphan events during the test.
     *
     * An orphan event is an event that was triggered by manually executing the
     * [`dispatch()`](https://symfony.com/doc/current/components/event_dispatcher.html#dispatch-the-event) method
     * of the EventDispatcher but was not handled by any listener after it was dispatched.
     *
     * ```php
     * <?php
     * $I->dontSeeOrphanEvent();
     * $I->dontSeeOrphanEvent('App\MyEvent');
     * $I->dontSeeOrphanEvent(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::dontSeeOrphanEvent()
     */
    public function dontSeeOrphanEvent(array|string|null $expected = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeOrphanEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that there were no orphan events during the test.
     *
     * An orphan event is an event that was triggered by manually executing the
     * [`dispatch()`](https://symfony.com/doc/current/components/event_dispatcher.html#dispatch-the-event) method
     * of the EventDispatcher but was not handled by any listener after it was dispatched.
     *
     * ```php
     * <?php
     * $I->dontSeeOrphanEvent();
     * $I->dontSeeOrphanEvent('App\MyEvent');
     * $I->dontSeeOrphanEvent(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::dontSeeOrphanEvent()
     */
    public function cantSeeOrphanEvent(array|string|null $expected = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeOrphanEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that there were no orphan events during the test.
     *
     * An orphan event is an event that was triggered by manually executing the
     * [`dispatch()`](https://symfony.com/doc/current/components/event_dispatcher.html#dispatch-the-event) method
     * of the EventDispatcher but was not handled by any listener after it was dispatched.
     *
     * ```php
     * <?php
     * $I->dontSeeOrphanEvent();
     * $I->dontSeeOrphanEvent('App\MyEvent');
     * $I->dontSeeOrphanEvent(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::dontSeeOrphanEvent()
     */
    public function tryToDontSeeOrphanEvent(array|string|null $expected = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeOrphanEvent', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeOrphanEvent and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeOrphanEvent()
     */
    public function retryDontSeeOrphanEvent(array|string|null $expected = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeOrphanEvent', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that one or more events were dispatched during the test.
     * Both regular and orphan events are checked.
     *
     * If you need to verify that expected event is not orphan,
     * add `dontSeeOrphanEvent` call.
     *
     * ```php
     *  <?php
     *  $I->seeEvent('App\MyEvent');
     *  $I->seeEvent(['App\MyEvent', 'App\MyOtherEvent']);
     *  ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::seeEvent()
     */
    public function seeEvent(array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that one or more events were dispatched during the test.
     * Both regular and orphan events are checked.
     *
     * If you need to verify that expected event is not orphan,
     * add `dontSeeOrphanEvent` call.
     *
     * ```php
     *  <?php
     *  $I->seeEvent('App\MyEvent');
     *  $I->seeEvent(['App\MyEvent', 'App\MyOtherEvent']);
     *  ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::seeEvent()
     */
    public function canSeeEvent(array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that one or more events were dispatched during the test.
     * Both regular and orphan events are checked.
     *
     * If you need to verify that expected event is not orphan,
     * add `dontSeeOrphanEvent` call.
     *
     * ```php
     *  <?php
     *  $I->seeEvent('App\MyEvent');
     *  $I->seeEvent(['App\MyEvent', 'App\MyOtherEvent']);
     *  ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::seeEvent()
     */
    public function tryToSeeEvent(array|string $expected): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeEvent', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeEvent and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeEvent()
     */
    public function retrySeeEvent(array|string $expected) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeEvent', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that one or more event listeners were called during the test.
     *
     * ```php
     * <?php
     * $I->seeEventListenerIsCalled('App\MyEventListener');
     * $I->seeEventListenerIsCalled(['App\MyEventListener', 'App\MyOtherEventListener']);
     * $I->seeEventListenerIsCalled('App\MyEventListener', 'my.event);
     * $I->seeEventListenerIsCalled('App\MyEventListener', ['my.event', 'my.other.event']);
     * ```
     *
     * @param class-string|class-string[] $expected
     * @param string|string[] $events
     * @see \Codeception\Module\Symfony::seeEventListenerIsCalled()
     */
    public function seeEventListenerIsCalled(object|array|string $expected, array|string $events = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeEventListenerIsCalled', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that one or more event listeners were called during the test.
     *
     * ```php
     * <?php
     * $I->seeEventListenerIsCalled('App\MyEventListener');
     * $I->seeEventListenerIsCalled(['App\MyEventListener', 'App\MyOtherEventListener']);
     * $I->seeEventListenerIsCalled('App\MyEventListener', 'my.event);
     * $I->seeEventListenerIsCalled('App\MyEventListener', ['my.event', 'my.other.event']);
     * ```
     *
     * @param class-string|class-string[] $expected
     * @param string|string[] $events
     * @see \Codeception\Module\Symfony::seeEventListenerIsCalled()
     */
    public function canSeeEventListenerIsCalled(object|array|string $expected, array|string $events = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeEventListenerIsCalled', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that one or more event listeners were called during the test.
     *
     * ```php
     * <?php
     * $I->seeEventListenerIsCalled('App\MyEventListener');
     * $I->seeEventListenerIsCalled(['App\MyEventListener', 'App\MyOtherEventListener']);
     * $I->seeEventListenerIsCalled('App\MyEventListener', 'my.event);
     * $I->seeEventListenerIsCalled('App\MyEventListener', ['my.event', 'my.other.event']);
     * ```
     *
     * @param class-string|class-string[] $expected
     * @param string|string[] $events
     * @see \Codeception\Module\Symfony::seeEventListenerIsCalled()
     */
    public function tryToSeeEventListenerIsCalled(object|array|string $expected, array|string $events = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeEventListenerIsCalled', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeEventListenerIsCalled and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeEventListenerIsCalled()
     */
    public function retrySeeEventListenerIsCalled(object|array|string $expected, array|string $events = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeEventListenerIsCalled', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that one or more event listeners were called during the test.
     *
     * ```php
     * <?php
     * $I->seeEventTriggered('App\MyEvent');
     * $I->seeEventTriggered(new App\Events\MyEvent());
     * $I->seeEventTriggered(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param object|string|string[] $expected
     * @deprecated Use `seeEventListenerIsCalled` instead.
     * @see \Codeception\Module\Symfony::seeEventTriggered()
     */
    public function seeEventTriggered(object|array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeEventTriggered', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that one or more event listeners were called during the test.
     *
     * ```php
     * <?php
     * $I->seeEventTriggered('App\MyEvent');
     * $I->seeEventTriggered(new App\Events\MyEvent());
     * $I->seeEventTriggered(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param object|string|string[] $expected
     * @deprecated Use `seeEventListenerIsCalled` instead.
     * @see \Codeception\Module\Symfony::seeEventTriggered()
     */
    public function canSeeEventTriggered(object|array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeEventTriggered', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that one or more event listeners were called during the test.
     *
     * ```php
     * <?php
     * $I->seeEventTriggered('App\MyEvent');
     * $I->seeEventTriggered(new App\Events\MyEvent());
     * $I->seeEventTriggered(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param object|string|string[] $expected
     * @deprecated Use `seeEventListenerIsCalled` instead.
     * @see \Codeception\Module\Symfony::seeEventTriggered()
     */
    public function tryToSeeEventTriggered(object|array|string $expected): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeEventTriggered', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeEventTriggered and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeEventTriggered()
     */
    public function retrySeeEventTriggered(object|array|string $expected) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeEventTriggered', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that one or more orphan events were dispatched during the test.
     *
     * An orphan event is an event that was triggered by manually executing the
     * [`dispatch()`](https://symfony.com/doc/current/components/event_dispatcher.html#dispatch-the-event) method
     * of the EventDispatcher but was not handled by any listener after it was dispatched.
     *
     * ```php
     * <?php
     * $I->seeOrphanEvent('App\MyEvent');
     * $I->seeOrphanEvent(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::seeOrphanEvent()
     */
    public function seeOrphanEvent(array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeOrphanEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that one or more orphan events were dispatched during the test.
     *
     * An orphan event is an event that was triggered by manually executing the
     * [`dispatch()`](https://symfony.com/doc/current/components/event_dispatcher.html#dispatch-the-event) method
     * of the EventDispatcher but was not handled by any listener after it was dispatched.
     *
     * ```php
     * <?php
     * $I->seeOrphanEvent('App\MyEvent');
     * $I->seeOrphanEvent(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::seeOrphanEvent()
     */
    public function canSeeOrphanEvent(array|string $expected): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeOrphanEvent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that one or more orphan events were dispatched during the test.
     *
     * An orphan event is an event that was triggered by manually executing the
     * [`dispatch()`](https://symfony.com/doc/current/components/event_dispatcher.html#dispatch-the-event) method
     * of the EventDispatcher but was not handled by any listener after it was dispatched.
     *
     * ```php
     * <?php
     * $I->seeOrphanEvent('App\MyEvent');
     * $I->seeOrphanEvent(['App\MyEvent', 'App\MyOtherEvent']);
     * ```
     *
     * @param string|string[] $expected
     * @see \Codeception\Module\Symfony::seeOrphanEvent()
     */
    public function tryToSeeOrphanEvent(array|string $expected): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeOrphanEvent', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeOrphanEvent and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeOrphanEvent()
     */
    public function retrySeeOrphanEvent(array|string $expected) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeOrphanEvent', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that there are no errors bound to the submitted form.
     *
     * ```php
     * <?php
     * $I->dontSeeFormErrors();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeFormErrors()
     */
    public function dontSeeFormErrors(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeFormErrors', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that there are no errors bound to the submitted form.
     *
     * ```php
     * <?php
     * $I->dontSeeFormErrors();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeFormErrors()
     */
    public function cantSeeFormErrors(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeFormErrors', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that there are no errors bound to the submitted form.
     *
     * ```php
     * <?php
     * $I->dontSeeFormErrors();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeFormErrors()
     */
    public function tryToDontSeeFormErrors(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeFormErrors', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeFormErrors and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeFormErrors()
     */
    public function retryDontSeeFormErrors() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeFormErrors', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that a form field has an error.
     * You can specify the expected error message as second parameter.
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessage('username');
     * $I->seeFormErrorMessage('username', 'Username is empty');
     * ```
     *
     * @param string|null $message
     * @see \Codeception\Module\Symfony::seeFormErrorMessage()
     */
    public function seeFormErrorMessage(string $field, ?string $message = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeFormErrorMessage', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that a form field has an error.
     * You can specify the expected error message as second parameter.
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessage('username');
     * $I->seeFormErrorMessage('username', 'Username is empty');
     * ```
     *
     * @param string|null $message
     * @see \Codeception\Module\Symfony::seeFormErrorMessage()
     */
    public function canSeeFormErrorMessage(string $field, ?string $message = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeFormErrorMessage', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that a form field has an error.
     * You can specify the expected error message as second parameter.
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessage('username');
     * $I->seeFormErrorMessage('username', 'Username is empty');
     * ```
     *
     * @param string|null $message
     * @see \Codeception\Module\Symfony::seeFormErrorMessage()
     */
    public function tryToSeeFormErrorMessage(string $field, ?string $message = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeFormErrorMessage', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeFormErrorMessage and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeFormErrorMessage()
     */
    public function retrySeeFormErrorMessage(string $field, ?string $message = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeFormErrorMessage', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that multiple fields on a form have errors.
     *
     * If you only specify the name of the fields, this method will
     * verify that the field contains at least one error of any type:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages(['telephone', 'address']);
     * ```
     *
     * If you want to specify the error messages, you can do so
     * by sending an associative array instead, with the key being
     * the name of the field and the error message the value.
     *
     * This method will validate that the expected error message
     * is contained in the actual error message, that is,
     * you can specify either the entire error message or just a part of it:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages([
     *     'address'   => 'The address is too long'
     *     'telephone' => 'too short', // the full error message is 'The telephone is too short'
     * ]);
     * ```
     *
     * If you don't want to specify the error message for some fields,
     * you can pass `null` as value instead of the message string,
     * or you can directly omit the value of that field. If that is the case,
     * it will be validated that that field has at least one error of any type:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages([
     *     'telephone' => 'too short',
     *     'address'   => null,
     *     'postal code',
     * ]);
     * ```
     *
     * @param string[] $expectedErrors
     * @see \Codeception\Module\Symfony::seeFormErrorMessages()
     */
    public function seeFormErrorMessages(array $expectedErrors): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeFormErrorMessages', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that multiple fields on a form have errors.
     *
     * If you only specify the name of the fields, this method will
     * verify that the field contains at least one error of any type:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages(['telephone', 'address']);
     * ```
     *
     * If you want to specify the error messages, you can do so
     * by sending an associative array instead, with the key being
     * the name of the field and the error message the value.
     *
     * This method will validate that the expected error message
     * is contained in the actual error message, that is,
     * you can specify either the entire error message or just a part of it:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages([
     *     'address'   => 'The address is too long'
     *     'telephone' => 'too short', // the full error message is 'The telephone is too short'
     * ]);
     * ```
     *
     * If you don't want to specify the error message for some fields,
     * you can pass `null` as value instead of the message string,
     * or you can directly omit the value of that field. If that is the case,
     * it will be validated that that field has at least one error of any type:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages([
     *     'telephone' => 'too short',
     *     'address'   => null,
     *     'postal code',
     * ]);
     * ```
     *
     * @param string[] $expectedErrors
     * @see \Codeception\Module\Symfony::seeFormErrorMessages()
     */
    public function canSeeFormErrorMessages(array $expectedErrors): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeFormErrorMessages', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that multiple fields on a form have errors.
     *
     * If you only specify the name of the fields, this method will
     * verify that the field contains at least one error of any type:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages(['telephone', 'address']);
     * ```
     *
     * If you want to specify the error messages, you can do so
     * by sending an associative array instead, with the key being
     * the name of the field and the error message the value.
     *
     * This method will validate that the expected error message
     * is contained in the actual error message, that is,
     * you can specify either the entire error message or just a part of it:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages([
     *     'address'   => 'The address is too long'
     *     'telephone' => 'too short', // the full error message is 'The telephone is too short'
     * ]);
     * ```
     *
     * If you don't want to specify the error message for some fields,
     * you can pass `null` as value instead of the message string,
     * or you can directly omit the value of that field. If that is the case,
     * it will be validated that that field has at least one error of any type:
     *
     * ```php
     * <?php
     * $I->seeFormErrorMessages([
     *     'telephone' => 'too short',
     *     'address'   => null,
     *     'postal code',
     * ]);
     * ```
     *
     * @param string[] $expectedErrors
     * @see \Codeception\Module\Symfony::seeFormErrorMessages()
     */
    public function tryToSeeFormErrorMessages(array $expectedErrors): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeFormErrorMessages', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeFormErrorMessages and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeFormErrorMessages()
     */
    public function retrySeeFormErrorMessages(array $expectedErrors) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeFormErrorMessages', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that there are one or more errors bound to the submitted form.
     *
     * ```php
     * <?php
     * $I->seeFormHasErrors();
     * ```
     * @see \Codeception\Module\Symfony::seeFormHasErrors()
     */
    public function seeFormHasErrors(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeFormHasErrors', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that there are one or more errors bound to the submitted form.
     *
     * ```php
     * <?php
     * $I->seeFormHasErrors();
     * ```
     * @see \Codeception\Module\Symfony::seeFormHasErrors()
     */
    public function canSeeFormHasErrors(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeFormHasErrors', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that there are one or more errors bound to the submitted form.
     *
     * ```php
     * <?php
     * $I->seeFormHasErrors();
     * ```
     * @see \Codeception\Module\Symfony::seeFormHasErrors()
     */
    public function tryToSeeFormHasErrors(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeFormHasErrors', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeFormHasErrors and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeFormHasErrors()
     */
    public function retrySeeFormHasErrors() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeFormHasErrors', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that no email was sent.
     * The check is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first; otherwise this check will *always* pass.
     * @see \Codeception\Module\Symfony::dontSeeEmailIsSent()
     */
    public function dontSeeEmailIsSent(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeEmailIsSent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that no email was sent.
     * The check is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first; otherwise this check will *always* pass.
     * @see \Codeception\Module\Symfony::dontSeeEmailIsSent()
     */
    public function cantSeeEmailIsSent(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeEmailIsSent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that no email was sent.
     * The check is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first; otherwise this check will *always* pass.
     * @see \Codeception\Module\Symfony::dontSeeEmailIsSent()
     */
    public function tryToDontSeeEmailIsSent(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeEmailIsSent', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeEmailIsSent and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeEmailIsSent()
     */
    public function retryDontSeeEmailIsSent() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeEmailIsSent', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks if the given number of emails was sent (default `$expectedCount`: 1).
     * The check is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect after sending the email, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     *
     * ```php
     * <?php
     * $I->seeEmailIsSent(2);
     * ```
     *
     * @param int $expectedCount The expected number of emails sent
     * @see \Codeception\Module\Symfony::seeEmailIsSent()
     */
    public function seeEmailIsSent(int $expectedCount = 1): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeEmailIsSent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks if the given number of emails was sent (default `$expectedCount`: 1).
     * The check is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect after sending the email, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     *
     * ```php
     * <?php
     * $I->seeEmailIsSent(2);
     * ```
     *
     * @param int $expectedCount The expected number of emails sent
     * @see \Codeception\Module\Symfony::seeEmailIsSent()
     */
    public function canSeeEmailIsSent(int $expectedCount = 1): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeEmailIsSent', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks if the given number of emails was sent (default `$expectedCount`: 1).
     * The check is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect after sending the email, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     *
     * ```php
     * <?php
     * $I->seeEmailIsSent(2);
     * ```
     *
     * @param int $expectedCount The expected number of emails sent
     * @see \Codeception\Module\Symfony::seeEmailIsSent()
     */
    public function tryToSeeEmailIsSent(int $expectedCount = 1): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeEmailIsSent', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeEmailIsSent and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeEmailIsSent()
     */
    public function retrySeeEmailIsSent(int $expectedCount = 1) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeEmailIsSent', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Returns the last sent email.
     * The function is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect after sending the email, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     * See also: [grabSentEmails()](https://codeception.com/docs/modules/Symfony#grabSentEmails)
     *
     * ```php
     * <?php
     * $email = $I->grabLastSentEmail();
     * $address = $email->getTo()[0];
     * $I->assertSame('john_doe@example.com', $address->getAddress());
     * ```
     * @see \Codeception\Module\Symfony::grabLastSentEmail()
     */
    public function grabLastSentEmail(): ?\Symfony\Component\Mime\Email {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabLastSentEmail', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabLastSentEmail and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::grabLastSentEmail()
     */
    public function retryGrabLastSentEmail() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabLastSentEmail', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Returns an array of all sent emails.
     * The function is based on `\Symfony\Component\Mailer\EventListener\MessageLoggerListener`, which means:
     * If your app performs an HTTP redirect after sending the email, you need to suppress it using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     * See also: [grabLastSentEmail()](https://codeception.com/docs/modules/Symfony#grabLastSentEmail)
     *
     * ```php
     * <?php
     * $emails = $I->grabSentEmails();
     * ```
     *
     * @return \Symfony\Component\Mime\Email[]
     * @see \Codeception\Module\Symfony::grabSentEmails()
     */
    public function grabSentEmails(): array {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabSentEmails', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabSentEmails and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::grabSentEmails()
     */
    public function retryGrabSentEmails() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabSentEmails', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that an email contains addresses with a [header](https://datatracker.ietf.org/doc/html/rfc4021)
     * `$headerName` and its expected value `$expectedValue`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailAddressContains('To', 'jane_doe@example.com');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailAddressContains()
     */
    public function assertEmailAddressContains(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailAddressContains', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that an email contains addresses with a [header](https://datatracker.ietf.org/doc/html/rfc4021)
     * `$headerName` and its expected value `$expectedValue`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailAddressContains('To', 'jane_doe@example.com');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailAddressContains()
     */
    public function tryToAssertEmailAddressContains(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailAddressContains', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailAddressContains and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailAddressContains()
     */
    public function retryAssertEmailAddressContains(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailAddressContains', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that an email has sent the specified number `$count` of attachments.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailAttachmentCount(1);
     * ```
     * @see \Codeception\Module\Symfony::assertEmailAttachmentCount()
     */
    public function assertEmailAttachmentCount(int $count, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailAttachmentCount', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that an email has sent the specified number `$count` of attachments.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailAttachmentCount(1);
     * ```
     * @see \Codeception\Module\Symfony::assertEmailAttachmentCount()
     */
    public function tryToAssertEmailAttachmentCount(int $count, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailAttachmentCount', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailAttachmentCount and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailAttachmentCount()
     */
    public function retryAssertEmailAttachmentCount(int $count, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailAttachmentCount', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that an email has a [header](https://datatracker.ietf.org/doc/html/rfc4021) `$headerName`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHasHeader('Bcc');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHasHeader()
     */
    public function assertEmailHasHeader(string $headerName, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailHasHeader', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that an email has a [header](https://datatracker.ietf.org/doc/html/rfc4021) `$headerName`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHasHeader('Bcc');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHasHeader()
     */
    public function tryToAssertEmailHasHeader(string $headerName, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailHasHeader', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailHasHeader and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailHasHeader()
     */
    public function retryAssertEmailHasHeader(string $headerName, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailHasHeader', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that the [header](https://datatracker.ietf.org/doc/html/rfc4021)
     * `$headerName` of an email is not the expected one `$expectedValue`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHeaderNotSame('To', 'john_doe@gmail.com');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHeaderNotSame()
     */
    public function assertEmailHeaderNotSame(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailHeaderNotSame', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that the [header](https://datatracker.ietf.org/doc/html/rfc4021)
     * `$headerName` of an email is not the expected one `$expectedValue`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHeaderNotSame('To', 'john_doe@gmail.com');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHeaderNotSame()
     */
    public function tryToAssertEmailHeaderNotSame(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailHeaderNotSame', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailHeaderNotSame and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailHeaderNotSame()
     */
    public function retryAssertEmailHeaderNotSame(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailHeaderNotSame', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that the [header](https://datatracker.ietf.org/doc/html/rfc4021)
     * `$headerName` of an email is the same as expected `$expectedValue`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHeaderSame('To', 'jane_doe@gmail.com');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHeaderSame()
     */
    public function assertEmailHeaderSame(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailHeaderSame', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that the [header](https://datatracker.ietf.org/doc/html/rfc4021)
     * `$headerName` of an email is the same as expected `$expectedValue`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHeaderSame('To', 'jane_doe@gmail.com');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHeaderSame()
     */
    public function tryToAssertEmailHeaderSame(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailHeaderSame', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailHeaderSame and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailHeaderSame()
     */
    public function retryAssertEmailHeaderSame(string $headerName, string $expectedValue, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailHeaderSame', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that the HTML body of an email contains `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHtmlBodyContains('Successful registration');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHtmlBodyContains()
     */
    public function assertEmailHtmlBodyContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailHtmlBodyContains', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that the HTML body of an email contains `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHtmlBodyContains('Successful registration');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHtmlBodyContains()
     */
    public function tryToAssertEmailHtmlBodyContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailHtmlBodyContains', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailHtmlBodyContains and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailHtmlBodyContains()
     */
    public function retryAssertEmailHtmlBodyContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailHtmlBodyContains', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that the HTML body of an email does not contain a text `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHtmlBodyNotContains('userpassword');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHtmlBodyNotContains()
     */
    public function assertEmailHtmlBodyNotContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailHtmlBodyNotContains', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that the HTML body of an email does not contain a text `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailHtmlBodyNotContains('userpassword');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailHtmlBodyNotContains()
     */
    public function tryToAssertEmailHtmlBodyNotContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailHtmlBodyNotContains', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailHtmlBodyNotContains and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailHtmlBodyNotContains()
     */
    public function retryAssertEmailHtmlBodyNotContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailHtmlBodyNotContains', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that an email does not have a [header](https://datatracker.ietf.org/doc/html/rfc4021) `$headerName`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailNotHasHeader('Bcc');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailNotHasHeader()
     */
    public function assertEmailNotHasHeader(string $headerName, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailNotHasHeader', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that an email does not have a [header](https://datatracker.ietf.org/doc/html/rfc4021) `$headerName`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailNotHasHeader('Bcc');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailNotHasHeader()
     */
    public function tryToAssertEmailNotHasHeader(string $headerName, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailNotHasHeader', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailNotHasHeader and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailNotHasHeader()
     */
    public function retryAssertEmailNotHasHeader(string $headerName, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailNotHasHeader', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify the text body of an email contains a `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailTextBodyContains('Example text body');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailTextBodyContains()
     */
    public function assertEmailTextBodyContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailTextBodyContains', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify the text body of an email contains a `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailTextBodyContains('Example text body');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailTextBodyContains()
     */
    public function tryToAssertEmailTextBodyContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailTextBodyContains', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailTextBodyContains and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailTextBodyContains()
     */
    public function retryAssertEmailTextBodyContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailTextBodyContains', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verify that the text body of an email does not contain a `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailTextBodyNotContains('My secret text body');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailTextBodyNotContains()
     */
    public function assertEmailTextBodyNotContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('assertEmailTextBodyNotContains', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verify that the text body of an email does not contain a `$text`.
     * If the Email object is not specified, the last email sent is used instead.
     *
     * ```php
     * <?php
     * $I->assertEmailTextBodyNotContains('My secret text body');
     * ```
     * @see \Codeception\Module\Symfony::assertEmailTextBodyNotContains()
     */
    public function tryToAssertEmailTextBodyNotContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('assertEmailTextBodyNotContains', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes assertEmailTextBodyNotContains and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::assertEmailTextBodyNotContains()
     */
    public function retryAssertEmailTextBodyNotContains(string $text, ?\Symfony\Component\Mime\Email $email = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('assertEmailTextBodyNotContains', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Grabs a Symfony parameter
     *
     * ```php
     * <?php
     * $I->grabParameter('app.business_name');
     * ```
     * This only works for explicitly set parameters (just using `bind` for Symfony's dependency injection is not enough).
     * @see \Codeception\Module\Symfony::grabParameter()
     */
    public function grabParameter(string $parameterName): \UnitEnum|array|string|int|float|bool|null {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabParameter', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabParameter and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::grabParameter()
     */
    public function retryGrabParameter(string $parameterName) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabParameter', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Opens web page by action name
     *
     * ```php
     * <?php
     * $I->amOnAction('PostController::index');
     * $I->amOnAction('HomeController');
     * $I->amOnAction('ArticleController', ['slug' => 'lorem-ipsum']);
     * ```
     * @see \Codeception\Module\Symfony::amOnAction()
     */
    public function amOnAction(string $action, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amOnAction', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Opens web page using route name and parameters.
     *
     * ```php
     * <?php
     * $I->amOnRoute('posts.create');
     * $I->amOnRoute('posts.show', ['id' => 34]);
     * ```
     * @see \Codeception\Module\Symfony::amOnRoute()
     */
    public function amOnRoute(string $routeName, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amOnRoute', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Invalidate previously cached routes.
     * @see \Codeception\Module\Symfony::invalidateCachedRouter()
     */
    public function invalidateCachedRouter(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('invalidateCachedRouter', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Invalidate previously cached routes.
     * @see \Codeception\Module\Symfony::invalidateCachedRouter()
     */
    public function tryToInvalidateCachedRouter(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('invalidateCachedRouter', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes invalidateCachedRouter and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::invalidateCachedRouter()
     */
    public function retryInvalidateCachedRouter() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('invalidateCachedRouter', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that current page matches action
     *
     * ```php
     * <?php
     * $I->seeCurrentActionIs('PostController::index');
     * $I->seeCurrentActionIs('HomeController');
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentActionIs()
     */
    public function seeCurrentActionIs(string $action): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeCurrentActionIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that current page matches action
     *
     * ```php
     * <?php
     * $I->seeCurrentActionIs('PostController::index');
     * $I->seeCurrentActionIs('HomeController');
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentActionIs()
     */
    public function canSeeCurrentActionIs(string $action): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeCurrentActionIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that current page matches action
     *
     * ```php
     * <?php
     * $I->seeCurrentActionIs('PostController::index');
     * $I->seeCurrentActionIs('HomeController');
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentActionIs()
     */
    public function tryToSeeCurrentActionIs(string $action): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeCurrentActionIs', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeCurrentActionIs and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeCurrentActionIs()
     */
    public function retrySeeCurrentActionIs(string $action) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeCurrentActionIs', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that current url matches route.
     *
     * ```php
     * <?php
     * $I->seeCurrentRouteIs('posts.index');
     * $I->seeCurrentRouteIs('posts.show', ['id' => 8]);
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentRouteIs()
     */
    public function seeCurrentRouteIs(string $routeName, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeCurrentRouteIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that current url matches route.
     *
     * ```php
     * <?php
     * $I->seeCurrentRouteIs('posts.index');
     * $I->seeCurrentRouteIs('posts.show', ['id' => 8]);
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentRouteIs()
     */
    public function canSeeCurrentRouteIs(string $routeName, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeCurrentRouteIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that current url matches route.
     *
     * ```php
     * <?php
     * $I->seeCurrentRouteIs('posts.index');
     * $I->seeCurrentRouteIs('posts.show', ['id' => 8]);
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentRouteIs()
     */
    public function tryToSeeCurrentRouteIs(string $routeName, array $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeCurrentRouteIs', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeCurrentRouteIs and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeCurrentRouteIs()
     */
    public function retrySeeCurrentRouteIs(string $routeName, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeCurrentRouteIs', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that current url matches route.
     * Unlike seeCurrentRouteIs, this can matches without exact route parameters
     *
     * ```php
     * <?php
     * $I->seeInCurrentRoute('my_blog_pages');
     * ```
     * @see \Codeception\Module\Symfony::seeInCurrentRoute()
     */
    public function seeInCurrentRoute(string $routeName): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInCurrentRoute', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that current url matches route.
     * Unlike seeCurrentRouteIs, this can matches without exact route parameters
     *
     * ```php
     * <?php
     * $I->seeInCurrentRoute('my_blog_pages');
     * ```
     * @see \Codeception\Module\Symfony::seeInCurrentRoute()
     */
    public function canSeeInCurrentRoute(string $routeName): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInCurrentRoute', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that current url matches route.
     * Unlike seeCurrentRouteIs, this can matches without exact route parameters
     *
     * ```php
     * <?php
     * $I->seeInCurrentRoute('my_blog_pages');
     * ```
     * @see \Codeception\Module\Symfony::seeInCurrentRoute()
     */
    public function tryToSeeInCurrentRoute(string $routeName): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInCurrentRoute', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInCurrentRoute and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeInCurrentRoute()
     */
    public function retrySeeInCurrentRoute(string $routeName) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInCurrentRoute', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Check that user is not authenticated.
     *
     * ```php
     * <?php
     * $I->dontSeeAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeAuthentication()
     */
    public function dontSeeAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Check that user is not authenticated.
     *
     * ```php
     * <?php
     * $I->dontSeeAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeAuthentication()
     */
    public function cantSeeAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Check that user is not authenticated.
     *
     * ```php
     * <?php
     * $I->dontSeeAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeAuthentication()
     */
    public function tryToDontSeeAuthentication(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeAuthentication and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeAuthentication()
     */
    public function retryDontSeeAuthentication() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeAuthentication', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Check that user is not authenticated with the 'remember me' option.
     *
     * ```php
     * <?php
     * $I->dontSeeRememberedAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeRememberedAuthentication()
     */
    public function dontSeeRememberedAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeRememberedAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Check that user is not authenticated with the 'remember me' option.
     *
     * ```php
     * <?php
     * $I->dontSeeRememberedAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeRememberedAuthentication()
     */
    public function cantSeeRememberedAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeRememberedAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Check that user is not authenticated with the 'remember me' option.
     *
     * ```php
     * <?php
     * $I->dontSeeRememberedAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::dontSeeRememberedAuthentication()
     */
    public function tryToDontSeeRememberedAuthentication(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeRememberedAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeRememberedAuthentication and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeRememberedAuthentication()
     */
    public function retryDontSeeRememberedAuthentication() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeRememberedAuthentication', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that a user is authenticated.
     *
     * ```php
     * <?php
     * $I->seeAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::seeAuthentication()
     */
    public function seeAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that a user is authenticated.
     *
     * ```php
     * <?php
     * $I->seeAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::seeAuthentication()
     */
    public function canSeeAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that a user is authenticated.
     *
     * ```php
     * <?php
     * $I->seeAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::seeAuthentication()
     */
    public function tryToSeeAuthentication(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeAuthentication and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeAuthentication()
     */
    public function retrySeeAuthentication() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeAuthentication', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that a user is authenticated with the 'remember me' option.
     *
     * ```php
     * <?php
     * $I->seeRememberedAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::seeRememberedAuthentication()
     */
    public function seeRememberedAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeRememberedAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that a user is authenticated with the 'remember me' option.
     *
     * ```php
     * <?php
     * $I->seeRememberedAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::seeRememberedAuthentication()
     */
    public function canSeeRememberedAuthentication(): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeRememberedAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that a user is authenticated with the 'remember me' option.
     *
     * ```php
     * <?php
     * $I->seeRememberedAuthentication();
     * ```
     * @see \Codeception\Module\Symfony::seeRememberedAuthentication()
     */
    public function tryToSeeRememberedAuthentication(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeRememberedAuthentication', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeRememberedAuthentication and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeRememberedAuthentication()
     */
    public function retrySeeRememberedAuthentication() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeRememberedAuthentication', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Check that the current user has a role
     *
     * ```php
     * <?php
     * $I->seeUserHasRole('ROLE_ADMIN');
     * ```
     * @see \Codeception\Module\Symfony::seeUserHasRole()
     */
    public function seeUserHasRole(string $role): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeUserHasRole', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Check that the current user has a role
     *
     * ```php
     * <?php
     * $I->seeUserHasRole('ROLE_ADMIN');
     * ```
     * @see \Codeception\Module\Symfony::seeUserHasRole()
     */
    public function canSeeUserHasRole(string $role): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeUserHasRole', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Check that the current user has a role
     *
     * ```php
     * <?php
     * $I->seeUserHasRole('ROLE_ADMIN');
     * ```
     * @see \Codeception\Module\Symfony::seeUserHasRole()
     */
    public function tryToSeeUserHasRole(string $role): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeUserHasRole', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeUserHasRole and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeUserHasRole()
     */
    public function retrySeeUserHasRole(string $role) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeUserHasRole', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Verifies that the current user has multiple roles
     *
     * ```php
     * <?php
     * $I->seeUserHasRoles(['ROLE_USER', 'ROLE_ADMIN']);
     * ```
     *
     * @param string[] $roles
     * @see \Codeception\Module\Symfony::seeUserHasRoles()
     */
    public function seeUserHasRoles(array $roles): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeUserHasRoles', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Verifies that the current user has multiple roles
     *
     * ```php
     * <?php
     * $I->seeUserHasRoles(['ROLE_USER', 'ROLE_ADMIN']);
     * ```
     *
     * @param string[] $roles
     * @see \Codeception\Module\Symfony::seeUserHasRoles()
     */
    public function canSeeUserHasRoles(array $roles): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeUserHasRoles', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Verifies that the current user has multiple roles
     *
     * ```php
     * <?php
     * $I->seeUserHasRoles(['ROLE_USER', 'ROLE_ADMIN']);
     * ```
     *
     * @param string[] $roles
     * @see \Codeception\Module\Symfony::seeUserHasRoles()
     */
    public function tryToSeeUserHasRoles(array $roles): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeUserHasRoles', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeUserHasRoles and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeUserHasRoles()
     */
    public function retrySeeUserHasRoles(array $roles) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeUserHasRoles', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Checks that the user's password would not benefit from rehashing.
     * If the user is not provided it is taken from the current session.
     *
     * You might use this function after performing tasks like registering a user or submitting a password update form.
     *
     * ```php
     * <?php
     * $I->seeUserPasswordDoesNotNeedRehash();
     * $I->seeUserPasswordDoesNotNeedRehash($user);
     * ```
     *
     * @param UserInterface|null $user
     * @see \Codeception\Module\Symfony::seeUserPasswordDoesNotNeedRehash()
     */
    public function seeUserPasswordDoesNotNeedRehash(?\Symfony\Component\Security\Core\User\UserInterface $user = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeUserPasswordDoesNotNeedRehash', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Checks that the user's password would not benefit from rehashing.
     * If the user is not provided it is taken from the current session.
     *
     * You might use this function after performing tasks like registering a user or submitting a password update form.
     *
     * ```php
     * <?php
     * $I->seeUserPasswordDoesNotNeedRehash();
     * $I->seeUserPasswordDoesNotNeedRehash($user);
     * ```
     *
     * @param UserInterface|null $user
     * @see \Codeception\Module\Symfony::seeUserPasswordDoesNotNeedRehash()
     */
    public function canSeeUserPasswordDoesNotNeedRehash(?\Symfony\Component\Security\Core\User\UserInterface $user = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeUserPasswordDoesNotNeedRehash', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Checks that the user's password would not benefit from rehashing.
     * If the user is not provided it is taken from the current session.
     *
     * You might use this function after performing tasks like registering a user or submitting a password update form.
     *
     * ```php
     * <?php
     * $I->seeUserPasswordDoesNotNeedRehash();
     * $I->seeUserPasswordDoesNotNeedRehash($user);
     * ```
     *
     * @param UserInterface|null $user
     * @see \Codeception\Module\Symfony::seeUserPasswordDoesNotNeedRehash()
     */
    public function tryToSeeUserPasswordDoesNotNeedRehash(?\Symfony\Component\Security\Core\User\UserInterface $user = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeUserPasswordDoesNotNeedRehash', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeUserPasswordDoesNotNeedRehash and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeUserPasswordDoesNotNeedRehash()
     */
    public function retrySeeUserPasswordDoesNotNeedRehash(?\Symfony\Component\Security\Core\User\UserInterface $user = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeUserPasswordDoesNotNeedRehash', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Grabs a service from the Symfony dependency injection container (DIC).
     * In "test" environment, Symfony uses a special `test.service_container`.
     * See the "[Public Versus Private Services](https://symfony.com/doc/current/service_container/alias_private.html#marking-services-as-public-private)" documentation.
     * Services that aren't injected somewhere into your app, need to be defined as `public` to be accessible by Codeception.
     *
     * ```php
     * <?php
     * $em = $I->grabService('doctrine');
     * ```
     *
     * @part services
     * @see \Codeception\Module\Symfony::grabService()
     */
    public function grabService(string $serviceId): object {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabService', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabService and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::grabService()
     */
    public function retryGrabService(string $serviceId) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabService', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Get service $serviceName and add it to the lists of persistent services.
     *
     * @part services
     * @see \Codeception\Module\Symfony::persistService()
     */
    public function persistService(string $serviceName): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('persistService', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Get service $serviceName and add it to the lists of persistent services.
     *
     * @part services
     * @see \Codeception\Module\Symfony::persistService()
     */
    public function tryToPersistService(string $serviceName): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('persistService', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes persistService and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::persistService()
     */
    public function retryPersistService(string $serviceName) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('persistService', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Get service $serviceName and add it to the lists of persistent services,
     * making that service persistent between tests.
     *
     * @part services
     * @see \Codeception\Module\Symfony::persistPermanentService()
     */
    public function persistPermanentService(string $serviceName): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('persistPermanentService', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Get service $serviceName and add it to the lists of persistent services,
     * making that service persistent between tests.
     *
     * @part services
     * @see \Codeception\Module\Symfony::persistPermanentService()
     */
    public function tryToPersistPermanentService(string $serviceName): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('persistPermanentService', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes persistPermanentService and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::persistPermanentService()
     */
    public function retryPersistPermanentService(string $serviceName) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('persistPermanentService', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Remove service $serviceName from the lists of persistent services.
     *
     * @part services
     * @see \Codeception\Module\Symfony::unpersistService()
     */
    public function unpersistService(string $serviceName): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('unpersistService', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Remove service $serviceName from the lists of persistent services.
     *
     * @part services
     * @see \Codeception\Module\Symfony::unpersistService()
     */
    public function tryToUnpersistService(string $serviceName): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('unpersistService', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes unpersistService and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::unpersistService()
     */
    public function retryUnpersistService(string $serviceName) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('unpersistService', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Login with the given user object.
     * The `$user` object must have a persistent identifier.
     * If you have more than one firewall or firewall context, you can specify the desired one as a parameter.
     *
     * ```php
     * <?php
     * $user = $I->grabEntityFromRepository(User::class, [
     *     'email' => 'john_doe@example.com'
     * ]);
     * $I->amLoggedInAs($user);
     * ```
     * @see \Codeception\Module\Symfony::amLoggedInAs()
     */
    public function amLoggedInAs(\Symfony\Component\Security\Core\User\UserInterface $user, string $firewallName = "main", ?string $firewallContext = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amLoggedInAs', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     *
     * @see \Codeception\Module\Symfony::amLoggedInWithToken()
     */
    public function amLoggedInWithToken(\Symfony\Component\Security\Core\Authentication\Token\TokenInterface $token, string $firewallName = "main", ?string $firewallContext = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Condition('amLoggedInWithToken', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Assert that a session attribute does not exist, or is not equal to the passed value.
     *
     * ```php
     * <?php
     * $I->dontSeeInSession('attribute');
     * $I->dontSeeInSession('attribute', 'value');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeInSession()
     */
    public function dontSeeInSession(string $attribute, mixed $value = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeInSession', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Assert that a session attribute does not exist, or is not equal to the passed value.
     *
     * ```php
     * <?php
     * $I->dontSeeInSession('attribute');
     * $I->dontSeeInSession('attribute', 'value');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeInSession()
     */
    public function cantSeeInSession(string $attribute, mixed $value = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeInSession', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Assert that a session attribute does not exist, or is not equal to the passed value.
     *
     * ```php
     * <?php
     * $I->dontSeeInSession('attribute');
     * $I->dontSeeInSession('attribute', 'value');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeInSession()
     */
    public function tryToDontSeeInSession(string $attribute, mixed $value = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeInSession', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeInSession and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeInSession()
     */
    public function retryDontSeeInSession(string $attribute, mixed $value = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeInSession', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Go to the configured logout url (by default: `/logout`).
     * This method includes redirection to the destination page configured after logout.
     *
     * See the Symfony documentation on ['Logging Out'](https://symfony.com/doc/current/security.html#logging-out).
     * @see \Codeception\Module\Symfony::goToLogoutPath()
     */
    public function goToLogoutPath(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('goToLogoutPath', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Go to the configured logout url (by default: `/logout`).
     * This method includes redirection to the destination page configured after logout.
     *
     * See the Symfony documentation on ['Logging Out'](https://symfony.com/doc/current/security.html#logging-out).
     * @see \Codeception\Module\Symfony::goToLogoutPath()
     */
    public function tryToGoToLogoutPath(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('goToLogoutPath', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes goToLogoutPath and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::goToLogoutPath()
     */
    public function retryGoToLogoutPath() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('goToLogoutPath', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Alias method for [`logoutProgrammatically()`](https://codeception.com/docs/modules/Symfony#logoutProgrammatically)
     *
     * ```php
     * <?php
     * $I->logout();
     * ```
     * @see \Codeception\Module\Symfony::logout()
     */
    public function logout(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('logout', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Alias method for [`logoutProgrammatically()`](https://codeception.com/docs/modules/Symfony#logoutProgrammatically)
     *
     * ```php
     * <?php
     * $I->logout();
     * ```
     * @see \Codeception\Module\Symfony::logout()
     */
    public function tryToLogout(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('logout', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes logout and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::logout()
     */
    public function retryLogout() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('logout', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Invalidates the current user's session and expires the session cookies.
     * This method does not include any redirects after logging out.
     *
     * ```php
     * <?php
     * $I->logoutProgrammatically();
     * ```
     * @see \Codeception\Module\Symfony::logoutProgrammatically()
     */
    public function logoutProgrammatically(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('logoutProgrammatically', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Invalidates the current user's session and expires the session cookies.
     * This method does not include any redirects after logging out.
     *
     * ```php
     * <?php
     * $I->logoutProgrammatically();
     * ```
     * @see \Codeception\Module\Symfony::logoutProgrammatically()
     */
    public function tryToLogoutProgrammatically(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('logoutProgrammatically', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes logoutProgrammatically and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::logoutProgrammatically()
     */
    public function retryLogoutProgrammatically() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('logoutProgrammatically', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Assert that a session attribute exists.
     *
     * ```php
     * <?php
     * $I->seeInSession('attribute');
     * $I->seeInSession('attribute', 'value');
     * ```
     * @see \Codeception\Module\Symfony::seeInSession()
     */
    public function seeInSession(string $attribute, mixed $value = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInSession', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Assert that a session attribute exists.
     *
     * ```php
     * <?php
     * $I->seeInSession('attribute');
     * $I->seeInSession('attribute', 'value');
     * ```
     * @see \Codeception\Module\Symfony::seeInSession()
     */
    public function canSeeInSession(string $attribute, mixed $value = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInSession', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Assert that a session attribute exists.
     *
     * ```php
     * <?php
     * $I->seeInSession('attribute');
     * $I->seeInSession('attribute', 'value');
     * ```
     * @see \Codeception\Module\Symfony::seeInSession()
     */
    public function tryToSeeInSession(string $attribute, mixed $value = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInSession', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInSession and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeInSession()
     */
    public function retrySeeInSession(string $attribute, mixed $value = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInSession', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Assert that the session has a given list of values.
     *
     * ```php
     * <?php
     * $I->seeSessionHasValues(['key1', 'key2']);
     * $I->seeSessionHasValues(['key1' => 'value1', 'key2' => 'value2']);
     * ```
     * @see \Codeception\Module\Symfony::seeSessionHasValues()
     */
    public function seeSessionHasValues(array $bindings): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeSessionHasValues', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Assert that the session has a given list of values.
     *
     * ```php
     * <?php
     * $I->seeSessionHasValues(['key1', 'key2']);
     * $I->seeSessionHasValues(['key1' => 'value1', 'key2' => 'value2']);
     * ```
     * @see \Codeception\Module\Symfony::seeSessionHasValues()
     */
    public function canSeeSessionHasValues(array $bindings): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeSessionHasValues', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Assert that the session has a given list of values.
     *
     * ```php
     * <?php
     * $I->seeSessionHasValues(['key1', 'key2']);
     * $I->seeSessionHasValues(['key1' => 'value1', 'key2' => 'value2']);
     * ```
     * @see \Codeception\Module\Symfony::seeSessionHasValues()
     */
    public function tryToSeeSessionHasValues(array $bindings): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeSessionHasValues', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeSessionHasValues and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeSessionHasValues()
     */
    public function retrySeeSessionHasValues(array $bindings) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeSessionHasValues', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that the time a request lasted is less than expected.
     *
     * If the page performed an HTTP redirect, only the time of the last request will be taken into account.
     * You can modify this behavior using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     *
     * Also, note that using code coverage can significantly increase the time it takes to resolve a request,
     * which could lead to unreliable results when used together.
     *
     * It is recommended to set [`rebootable_client`](https://codeception.com/docs/modules/Symfony#Config) to `true` (=default),
     * cause otherwise this assertion gives false results if you access multiple pages in a row, or if your app performs a redirect.
     *
     * @param int|float $expectedMilliseconds The expected time in milliseconds
     * @see \Codeception\Module\Symfony::seeRequestTimeIsLessThan()
     */
    public function seeRequestTimeIsLessThan(int|float $expectedMilliseconds): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeRequestTimeIsLessThan', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that the time a request lasted is less than expected.
     *
     * If the page performed an HTTP redirect, only the time of the last request will be taken into account.
     * You can modify this behavior using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     *
     * Also, note that using code coverage can significantly increase the time it takes to resolve a request,
     * which could lead to unreliable results when used together.
     *
     * It is recommended to set [`rebootable_client`](https://codeception.com/docs/modules/Symfony#Config) to `true` (=default),
     * cause otherwise this assertion gives false results if you access multiple pages in a row, or if your app performs a redirect.
     *
     * @param int|float $expectedMilliseconds The expected time in milliseconds
     * @see \Codeception\Module\Symfony::seeRequestTimeIsLessThan()
     */
    public function canSeeRequestTimeIsLessThan(int|float $expectedMilliseconds): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeRequestTimeIsLessThan', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that the time a request lasted is less than expected.
     *
     * If the page performed an HTTP redirect, only the time of the last request will be taken into account.
     * You can modify this behavior using [stopFollowingRedirects()](https://codeception.com/docs/modules/Symfony#stopFollowingRedirects) first.
     *
     * Also, note that using code coverage can significantly increase the time it takes to resolve a request,
     * which could lead to unreliable results when used together.
     *
     * It is recommended to set [`rebootable_client`](https://codeception.com/docs/modules/Symfony#Config) to `true` (=default),
     * cause otherwise this assertion gives false results if you access multiple pages in a row, or if your app performs a redirect.
     *
     * @param int|float $expectedMilliseconds The expected time in milliseconds
     * @see \Codeception\Module\Symfony::seeRequestTimeIsLessThan()
     */
    public function tryToSeeRequestTimeIsLessThan(int|float $expectedMilliseconds): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeRequestTimeIsLessThan', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeRequestTimeIsLessThan and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeRequestTimeIsLessThan()
     */
    public function retrySeeRequestTimeIsLessThan(int|float $expectedMilliseconds) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeRequestTimeIsLessThan', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that a template was not rendered in the response.
     *
     * ```php
     * <?php
     * $I->dontSeeRenderedTemplate('home.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeRenderedTemplate()
     */
    public function dontSeeRenderedTemplate(string $template): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeRenderedTemplate', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that a template was not rendered in the response.
     *
     * ```php
     * <?php
     * $I->dontSeeRenderedTemplate('home.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeRenderedTemplate()
     */
    public function cantSeeRenderedTemplate(string $template): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeRenderedTemplate', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that a template was not rendered in the response.
     *
     * ```php
     * <?php
     * $I->dontSeeRenderedTemplate('home.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeRenderedTemplate()
     */
    public function tryToDontSeeRenderedTemplate(string $template): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeRenderedTemplate', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeRenderedTemplate and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeRenderedTemplate()
     */
    public function retryDontSeeRenderedTemplate(string $template) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeRenderedTemplate', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that the current template matches the expected template.
     *
     * ```php
     * <?php
     * $I->seeCurrentTemplateIs('home.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentTemplateIs()
     */
    public function seeCurrentTemplateIs(string $expectedTemplate): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeCurrentTemplateIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that the current template matches the expected template.
     *
     * ```php
     * <?php
     * $I->seeCurrentTemplateIs('home.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentTemplateIs()
     */
    public function canSeeCurrentTemplateIs(string $expectedTemplate): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeCurrentTemplateIs', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that the current template matches the expected template.
     *
     * ```php
     * <?php
     * $I->seeCurrentTemplateIs('home.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::seeCurrentTemplateIs()
     */
    public function tryToSeeCurrentTemplateIs(string $expectedTemplate): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeCurrentTemplateIs', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeCurrentTemplateIs and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeCurrentTemplateIs()
     */
    public function retrySeeCurrentTemplateIs(string $expectedTemplate) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeCurrentTemplateIs', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that a template was rendered in the response.
     * That includes templates built with [inheritance](https://twig.symfony.com/doc/3.x/templates.html#template-inheritance).
     *
     * ```php
     * <?php
     * $I->seeRenderedTemplate('home.html.twig');
     * $I->seeRenderedTemplate('layout.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::seeRenderedTemplate()
     */
    public function seeRenderedTemplate(string $template): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeRenderedTemplate', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that a template was rendered in the response.
     * That includes templates built with [inheritance](https://twig.symfony.com/doc/3.x/templates.html#template-inheritance).
     *
     * ```php
     * <?php
     * $I->seeRenderedTemplate('home.html.twig');
     * $I->seeRenderedTemplate('layout.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::seeRenderedTemplate()
     */
    public function canSeeRenderedTemplate(string $template): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeRenderedTemplate', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that a template was rendered in the response.
     * That includes templates built with [inheritance](https://twig.symfony.com/doc/3.x/templates.html#template-inheritance).
     *
     * ```php
     * <?php
     * $I->seeRenderedTemplate('home.html.twig');
     * $I->seeRenderedTemplate('layout.html.twig');
     * ```
     * @see \Codeception\Module\Symfony::seeRenderedTemplate()
     */
    public function tryToSeeRenderedTemplate(string $template): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeRenderedTemplate', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeRenderedTemplate and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeRenderedTemplate()
     */
    public function retrySeeRenderedTemplate(string $template) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeRenderedTemplate', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that the given subject fails validation.
     * This assertion does not concern the exact number of violations.
     *
     * ```php
     * <?php
     * $I->dontSeeViolatedConstraint($subject);
     * $I->dontSeeViolatedConstraint($subject, 'propertyName');
     * $I->dontSeeViolatedConstraint($subject, 'propertyName', 'Symfony\Validator\ConstraintClass');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeViolatedConstraint()
     */
    public function dontSeeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeViolatedConstraint', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that the given subject fails validation.
     * This assertion does not concern the exact number of violations.
     *
     * ```php
     * <?php
     * $I->dontSeeViolatedConstraint($subject);
     * $I->dontSeeViolatedConstraint($subject, 'propertyName');
     * $I->dontSeeViolatedConstraint($subject, 'propertyName', 'Symfony\Validator\ConstraintClass');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeViolatedConstraint()
     */
    public function cantSeeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeViolatedConstraint', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that the given subject fails validation.
     * This assertion does not concern the exact number of violations.
     *
     * ```php
     * <?php
     * $I->dontSeeViolatedConstraint($subject);
     * $I->dontSeeViolatedConstraint($subject, 'propertyName');
     * $I->dontSeeViolatedConstraint($subject, 'propertyName', 'Symfony\Validator\ConstraintClass');
     * ```
     * @see \Codeception\Module\Symfony::dontSeeViolatedConstraint()
     */
    public function tryToDontSeeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeViolatedConstraint', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeViolatedConstraint and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::dontSeeViolatedConstraint()
     */
    public function retryDontSeeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeViolatedConstraint', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that the given subject passes validation.
     * This assertion does not concern the exact number of violations.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraint($subject);
     * $I->seeViolatedConstraint($subject, 'propertyName');
     * $I->seeViolatedConstraint($subject, 'propertyName', 'Symfony\Validator\ConstraintClass');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraint()
     */
    public function seeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeViolatedConstraint', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that the given subject passes validation.
     * This assertion does not concern the exact number of violations.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraint($subject);
     * $I->seeViolatedConstraint($subject, 'propertyName');
     * $I->seeViolatedConstraint($subject, 'propertyName', 'Symfony\Validator\ConstraintClass');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraint()
     */
    public function canSeeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeViolatedConstraint', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that the given subject passes validation.
     * This assertion does not concern the exact number of violations.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraint($subject);
     * $I->seeViolatedConstraint($subject, 'propertyName');
     * $I->seeViolatedConstraint($subject, 'propertyName', 'Symfony\Validator\ConstraintClass');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraint()
     */
    public function tryToSeeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeViolatedConstraint', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeViolatedConstraint and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeViolatedConstraint()
     */
    public function retrySeeViolatedConstraint(mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeViolatedConstraint', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts the exact number of violations for the given subject.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraintsCount(3, $subject);
     * $I->seeViolatedConstraintsCount(2, $subject, 'propertyName');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraintsCount()
     */
    public function seeViolatedConstraintsCount(int $expected, mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeViolatedConstraintsCount', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts the exact number of violations for the given subject.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraintsCount(3, $subject);
     * $I->seeViolatedConstraintsCount(2, $subject, 'propertyName');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraintsCount()
     */
    public function canSeeViolatedConstraintsCount(int $expected, mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeViolatedConstraintsCount', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts the exact number of violations for the given subject.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraintsCount(3, $subject);
     * $I->seeViolatedConstraintsCount(2, $subject, 'propertyName');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraintsCount()
     */
    public function tryToSeeViolatedConstraintsCount(int $expected, mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeViolatedConstraintsCount', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeViolatedConstraintsCount and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeViolatedConstraintsCount()
     */
    public function retrySeeViolatedConstraintsCount(int $expected, mixed $subject, ?string $propertyPath = NULL, ?string $constraint = NULL) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeViolatedConstraintsCount', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Asserts that a constraint violation message or a part of it is present in the subject's violations.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraintMessage('too short', $user, 'address');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraintMessage()
     */
    public function seeViolatedConstraintMessage(string $expected, mixed $subject, string $propertyPath): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeViolatedConstraintMessage', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Asserts that a constraint violation message or a part of it is present in the subject's violations.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraintMessage('too short', $user, 'address');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraintMessage()
     */
    public function canSeeViolatedConstraintMessage(string $expected, mixed $subject, string $propertyPath): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeViolatedConstraintMessage', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Asserts that a constraint violation message or a part of it is present in the subject's violations.
     *
     * ```php
     * <?php
     * $I->seeViolatedConstraintMessage('too short', $user, 'address');
     * ```
     * @see \Codeception\Module\Symfony::seeViolatedConstraintMessage()
     */
    public function tryToSeeViolatedConstraintMessage(string $expected, mixed $subject, string $propertyPath): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeViolatedConstraintMessage', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeViolatedConstraintMessage and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Symfony::seeViolatedConstraintMessage()
     */
    public function retrySeeViolatedConstraintMessage(string $expected, mixed $subject, string $propertyPath) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeViolatedConstraintMessage', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * HOOK to be executed when config changes with `_reconfigure`.
     * @see \Codeception\Module\Doctrine2::onReconfigure()
     */
    public function onReconfigure(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('onReconfigure', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * HOOK to be executed when config changes with `_reconfigure`.
     * @see \Codeception\Module\Doctrine2::onReconfigure()
     */
    public function tryToOnReconfigure(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('onReconfigure', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes onReconfigure and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::onReconfigure()
     */
    public function retryOnReconfigure() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('onReconfigure', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Performs $em->flush();
     * @see \Codeception\Module\Doctrine2::flushToDatabase()
     */
    public function flushToDatabase(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('flushToDatabase', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Performs $em->flush();
     * @see \Codeception\Module\Doctrine2::flushToDatabase()
     */
    public function tryToFlushToDatabase(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('flushToDatabase', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes flushToDatabase and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::flushToDatabase()
     */
    public function retryFlushToDatabase() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('flushToDatabase', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Performs $em->refresh() on every passed entity:
     *
     * ``` php
     * $I->refreshEntities($user);
     * $I->refreshEntities([$post1, $post2, $post3]]);
     * ```
     *
     * This can useful in acceptance tests where entity can become invalid due to
     * external (relative to entity manager used in tests) changes.
     *
     * @param object|object[] $entities
     * @see \Codeception\Module\Doctrine2::refreshEntities()
     */
    public function refreshEntities($entities): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('refreshEntities', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Performs $em->refresh() on every passed entity:
     *
     * ``` php
     * $I->refreshEntities($user);
     * $I->refreshEntities([$post1, $post2, $post3]]);
     * ```
     *
     * This can useful in acceptance tests where entity can become invalid due to
     * external (relative to entity manager used in tests) changes.
     *
     * @param object|object[] $entities
     * @see \Codeception\Module\Doctrine2::refreshEntities()
     */
    public function tryToRefreshEntities($entities): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('refreshEntities', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes refreshEntities and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::refreshEntities()
     */
    public function retryRefreshEntities($entities) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('refreshEntities', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Performs $em->clear():
     *
     * ``` php
     * $I->clearEntityManager();
     * ```
     * @see \Codeception\Module\Doctrine2::clearEntityManager()
     */
    public function clearEntityManager(): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('clearEntityManager', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Performs $em->clear():
     *
     * ``` php
     * $I->clearEntityManager();
     * ```
     * @see \Codeception\Module\Doctrine2::clearEntityManager()
     */
    public function tryToClearEntityManager(): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('clearEntityManager', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes clearEntityManager and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::clearEntityManager()
     */
    public function retryClearEntityManager() {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('clearEntityManager', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Mocks the repository.
     *
     * With this action you can redefine any method of any repository.
     * Please, note: this fake repositories will be accessible through entity manager till the end of test.
     *
     * Example:
     *
     * ``` php
     * <?php
     *
     * $I->haveFakeRepository(User::class, ['findByUsername' => function($username) { return null; }]);
     *
     * ```
     *
     * This creates a stub class for Entity\User repository with redefined method findByUsername,
     * which will always return the NULL value.
     *
     * @param class-string $className
     * @param array<string, callable> $methods
     * @see \Codeception\Module\Doctrine2::haveFakeRepository()
     */
    public function haveFakeRepository(string $className, array $methods = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('haveFakeRepository', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Persists a record into the repository.
     * This method creates an entity, and sets its properties directly (via reflection).
     * Setters of the entity won't be executed, but you can create almost any entity and save it to the database.
     * If the entity has a constructor, for optional parameters the default value will be used and for non-optional parameters the given fields (with a matching name) will be passed when calling the constructor before the properties get set directly (via reflection).
     *
     * Returns the primary key of the newly created entity. The primary key value is extracted using Reflection API.
     * If the primary key is composite, an array of values is returned.
     *
     * ```php
     * $I->haveInRepository(User::class, ['name' => 'davert']);
     * ```
     *
     * This method also accepts instances as first argument, which is useful when the entity constructor
     * has some arguments:
     *
     * ```php
     * $I->haveInRepository(new User($arg), ['name' => 'davert']);
     * ```
     *
     * Alternatively, constructor arguments can be passed by name. Given User constructor signature is `__constructor($arg)`, the example above could be rewritten like this:
     *
     * ```php
     * $I->haveInRepository(User::class, ['arg' => $arg, 'name' => 'davert']);
     * ```
     *
     * If the entity has relations, they can be populated too. In case of
     * [OneToMany](https://www.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html#one-to-many-bidirectional)
     * the following format is expected:
     *
     * ```php
     * $I->haveInRepository(User::class, [
     *     'name' => 'davert',
     *     'posts' => [
     *         ['title' => 'Post 1'],
     *         ['title' => 'Post 2'],
     *     ],
     * ]);
     * ```
     *
     * For [ManyToOne](https://www.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html#many-to-one-unidirectional)
     * the format is slightly different:
     *
     * ```php
     * $I->haveInRepository(User::class, [
     *     'name' => 'davert',
     *     'post' => [
     *         'title' => 'Post 1',
     *     ],
     * ]);
     * ```
     *
     * This works recursively, so you can create deep structures in a single call.
     *
     * Note that `$em->persist()`, `$em->refresh()`, and `$em->flush()` are called every time.
     *
     * @template T of object
     * @param class-string<T>|T $classNameOrInstance
     * @param array $data
     * @return mixed
     * @see \Codeception\Module\Doctrine2::haveInRepository()
     */
    public function haveInRepository($classNameOrInstance, array $data = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('haveInRepository', func_get_args()));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Loads fixtures. Fixture can be specified as a fully qualified class name,
     * an instance, or an array of class names/instances.
     *
     * ```php
     * <?php
     * $I->loadFixtures(AppFixtures::class);
     * $I->loadFixtures([AppFixtures1::class, AppFixtures2::class]);
     * $I->loadFixtures(new AppFixtures);
     * ```
     *
     * By default fixtures are loaded in 'append' mode. To replace all
     * data in database, use `false` as second parameter:
     *
     * ```php
     * <?php
     * $I->loadFixtures(AppFixtures::class, false);
     * ```
     *
     * This method requires [`doctrine/data-fixtures`](https://github.com/doctrine/data-fixtures) to be installed.
     *
     * @param class-string<FixtureInterface>|class-string<FixtureInterface>[]|list<FixtureInterface> $fixtures
     * @param bool $append
     * @throws ModuleException
     * @throws ModuleRequireException
     * @see \Codeception\Module\Doctrine2::loadFixtures()
     */
    public function loadFixtures($fixtures, bool $append = true): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('loadFixtures', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Loads fixtures. Fixture can be specified as a fully qualified class name,
     * an instance, or an array of class names/instances.
     *
     * ```php
     * <?php
     * $I->loadFixtures(AppFixtures::class);
     * $I->loadFixtures([AppFixtures1::class, AppFixtures2::class]);
     * $I->loadFixtures(new AppFixtures);
     * ```
     *
     * By default fixtures are loaded in 'append' mode. To replace all
     * data in database, use `false` as second parameter:
     *
     * ```php
     * <?php
     * $I->loadFixtures(AppFixtures::class, false);
     * ```
     *
     * This method requires [`doctrine/data-fixtures`](https://github.com/doctrine/data-fixtures) to be installed.
     *
     * @param class-string<FixtureInterface>|class-string<FixtureInterface>[]|list<FixtureInterface> $fixtures
     * @param bool $append
     * @throws ModuleException
     * @throws ModuleRequireException
     * @see \Codeception\Module\Doctrine2::loadFixtures()
     */
    public function tryToLoadFixtures($fixtures, bool $append = true): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('loadFixtures', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes loadFixtures and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::loadFixtures()
     */
    public function retryLoadFixtures($fixtures, bool $append = true) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('loadFixtures', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Flushes changes to database, and executes a query with parameters defined in an array.
     * You can use entity associations to build complex queries.
     *
     * Example:
     *
     * ``` php
     * <?php
     * $I->seeInRepository(User::class, ['name' => 'davert']);
     * $I->seeInRepository(User::class, ['name' => 'davert', 'Company' => ['name' => 'Codegyre']]);
     * $I->seeInRepository(Client::class, ['User' => ['Company' => ['name' => 'Codegyre']]]);
     * ```
     *
     * Fails if record for given criteria can\'t be found,
     *
     * @param class-string $entity
     * @param array $params
     * @return void
     * @see \Codeception\Module\Doctrine2::seeInRepository()
     */
    public function seeInRepository(string $entity, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Assertion('seeInRepository', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Flushes changes to database, and executes a query with parameters defined in an array.
     * You can use entity associations to build complex queries.
     *
     * Example:
     *
     * ``` php
     * <?php
     * $I->seeInRepository(User::class, ['name' => 'davert']);
     * $I->seeInRepository(User::class, ['name' => 'davert', 'Company' => ['name' => 'Codegyre']]);
     * $I->seeInRepository(Client::class, ['User' => ['Company' => ['name' => 'Codegyre']]]);
     * ```
     *
     * Fails if record for given criteria can\'t be found,
     *
     * @param class-string $entity
     * @param array $params
     * @return void
     * @see \Codeception\Module\Doctrine2::seeInRepository()
     */
    public function canSeeInRepository(string $entity, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('seeInRepository', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Flushes changes to database, and executes a query with parameters defined in an array.
     * You can use entity associations to build complex queries.
     *
     * Example:
     *
     * ``` php
     * <?php
     * $I->seeInRepository(User::class, ['name' => 'davert']);
     * $I->seeInRepository(User::class, ['name' => 'davert', 'Company' => ['name' => 'Codegyre']]);
     * $I->seeInRepository(Client::class, ['User' => ['Company' => ['name' => 'Codegyre']]]);
     * ```
     *
     * Fails if record for given criteria can\'t be found,
     *
     * @param class-string $entity
     * @param array $params
     * @return void
     * @see \Codeception\Module\Doctrine2::seeInRepository()
     */
    public function tryToSeeInRepository(string $entity, array $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('seeInRepository', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes seeInRepository and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::seeInRepository()
     */
    public function retrySeeInRepository(string $entity, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('seeInRepository', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Flushes changes to database and performs `findOneBy()` call for current repository.
     *
     * @param class-string $entity
     * @param array $params
     * @return void
     * @see \Codeception\Module\Doctrine2::dontSeeInRepository()
     */
    public function dontSeeInRepository(string $entity, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\Action('dontSeeInRepository', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Conditional Assertion: Test won't be stopped on fail
     * Flushes changes to database and performs `findOneBy()` call for current repository.
     *
     * @param class-string $entity
     * @param array $params
     * @return void
     * @see \Codeception\Module\Doctrine2::dontSeeInRepository()
     */
    public function cantSeeInRepository(string $entity, array $params = []): void {
        $this->getScenario()->runStep(new \Codeception\Step\ConditionalAssertion('dontSeeInRepository', func_get_args()));
    }
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * [!] Test won't be stopped on fail. Error won't be logged 
     * Flushes changes to database and performs `findOneBy()` call for current repository.
     *
     * @param class-string $entity
     * @param array $params
     * @return void
     * @see \Codeception\Module\Doctrine2::dontSeeInRepository()
     */
    public function tryToDontSeeInRepository(string $entity, array $params = []): bool {
        return $this->getScenario()->runStep(new \Codeception\Step\TryTo('dontSeeInRepository', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes dontSeeInRepository and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::dontSeeInRepository()
     */
    public function retryDontSeeInRepository(string $entity, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('dontSeeInRepository', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Selects field value from repository.
     * It builds a query based on an array of parameters.
     * You can use entity associations to build complex queries.
     * For Symfony users, it's recommended to [use the entity's repository instead](#Grabbing-Entities-with-Symfony)
     *
     * Example:
     *
     * ``` php
     * <?php
     * $email = $I->grabFromRepository(User::class, 'email', ['name' => 'davert']);
     * ```
     *
     * @param class-string $entity
     * @param string $field
     * @param array $params
     * @return mixed
     * @see \Codeception\Module\Doctrine2::grabFromRepository()
     */
    public function grabFromRepository(string $entity, string $field, array $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabFromRepository', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabFromRepository and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::grabFromRepository()
     */
    public function retryGrabFromRepository(string $entity, string $field, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabFromRepository', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Selects entities from repository.
     * It builds a query based on an array of parameters.
     * You can use entity associations to build complex queries.
     * For Symfony users, it's recommended to [use the entity's repository instead](#Grabbing-Entities-with-Symfony)
     *
     * Example:
     *
     * ``` php
     * <?php
     * $users = $I->grabEntitiesFromRepository(User::class, ['name' => 'davert']);
     * ```
     *
     * @template T of object
     * @param class-string<T> $entity
     * @param array $params . For `IS NULL`, use `['field' => null]`
     * @return list<T>
     * @see \Codeception\Module\Doctrine2::grabEntitiesFromRepository()
     */
    public function grabEntitiesFromRepository(string $entity, array $params = []): array {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabEntitiesFromRepository', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabEntitiesFromRepository and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::grabEntitiesFromRepository()
     */
    public function retryGrabEntitiesFromRepository(string $entity, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabEntitiesFromRepository', func_get_args(), $retryNum, $retryInterval));
    }

 
    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     * Selects a single entity from repository.
     * It builds a query based on an array of parameters.
     * You can use entity associations to build complex queries.
     * For Symfony users, it's recommended to [use the entity's repository instead](#Grabbing-Entities-with-Symfony)
     *
     * Example:
     *
     * ``` php
     * <?php
     * $user = $I->grabEntityFromRepository(User::class, ['id' => '1234']);
     * ```
     *
     * @template T of object
     * @param class-string<T> $entity
     * @param array $params . For `IS NULL`, use `['field' => null]`
     * @return T
     * @version 1.1
     * @see \Codeception\Module\Doctrine2::grabEntityFromRepository()
     */
    public function grabEntityFromRepository(string $entity, array $params = []) {
        return $this->getScenario()->runStep(new \Codeception\Step\Action('grabEntityFromRepository', func_get_args()));
    }
    /**
     * [!] Method is generated.
     * 
     * * Executes grabEntityFromRepository and retries on failure.
     * 
     * Retry number and interval set by $I->retry();
     *
     * @see \Codeception\Module\Doctrine2::grabEntityFromRepository()
     */
    public function retryGrabEntityFromRepository(string $entity, array $params = []) {
        $retryNum = isset($this->retryNum) ? $this->retryNum : 1;
        $retryInterval = isset($this->retryInterval) ? $this->retryInterval : 200;
        return $this->getScenario()->runStep(new \Codeception\Step\Retry('grabEntityFromRepository', func_get_args(), $retryNum, $retryInterval));
    }
}
